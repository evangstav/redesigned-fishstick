<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Strength Tracker">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#673AB7">
    <title>Personalized Strength Plan Tracker</title>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiUGVyc29uYWxpemVkIFN0cmVuZ3RoIFRyYWNrZXIiLCJzaG9ydF9uYW1lIjoiU3RyZW5ndGggVHJhY2tlciIsInN0YXJ0X3VybCI6Ii4vIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiI2Y1ZjVmNSIsInRoZW1lX2NvbG9yIjoiIzY3M0FCNyIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSnhOalFpSUdobGFXZG9kRDBpTmpZMElqNDhjbVZqZENCM2FXUjBhRDBpTmpZMElpQm9aV2xuYUhROUlqWTJOQ0lpSUdacGJHdzlJaU0yTnpOQlFqY2lMejQ4ZEdWNGRDQjRQU0l6TWpJaUlIazlJak0wTWlJZ1ptbHNiRDBpSTJabVptWm1aaUlnWm05dWRDMW1ZVzFwYkhrOUlrRnlhV0ZzSWlCbWIyNTBMWE5wZW1VOUlqWXdJaUJtYjI1MExYZGxhV2RvZEQwaVltOXNaQ0lpZEhWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJK1UwUThMM1JsZUhRK1BDOW5Qand2YzNabkdBPT0iLCJzaXplcyI6IjY0eDY0IiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifSx7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owb
WFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNKeU5UWWlJR2hsYVdkb2REMGlORFU0SWo0OGNtVmpkQ0IzYVdSMGFEMGlORFU0SWlCb1pXbG5hSFE5SWpRMU9DSWdabWxzYkQwaUl6WTNNMEZDTnlJdlBqeDBaWGgwSUhnOUlqRXlPQ0lnZVQwaWJUSTBOU0krU1VRa0wwVjNQekFZV2FuQmhjM2RZMXZabGI1SkhPQTVtU0ZOajZvSUl3cFdHSHN2Ly9NSGVjaUJJYkNhMkgzb3ZqNWVMaDFBZ3lndCIsInNpemVzIjoiMTI4eDEyOCIsInR5cGUiOiJpbWFnZS9zdmcreG1sIn0seyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSnFOVEVpSUdobGFXZG9kRDBpTlRFeUlqNDhjbVZqZENCM2FXUjBhRDBpTlRFeUlpQm9aV2xuYUhROUlqVXhNaUlnWm1sc2JEMGlJeUEyTnpNVaUJjNVlUVlpUzVjdkwzUmxlSFErUEhSbGVIUWdlRDBpTWpVMklpQjVQU0l6TmpZaUlHWnBiR3c5SWlObVptWm1abVlpSUdadmJuUXRabUZ0YVd4NVBTSkJjbWxoYkNJZ1ptOXVkQzF6YVhwbFBTSXpNaUlnWm05dWRDMTNaV2xuYUhROUltSnZiR1FpSUhSMWVIUXRZVzVqYUc5eVBTSnRhV1JrYkdVaTVV", "sizes": "256x256", "type": "image/svg+xml"}]}
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --md-purple-500: #673AB7; /* Primary Purple */
            --md-purple-700: #512DA8; /* Darker Purple for Headers/Accents */
            --md-purple-100: #D1C4E9; /* Lighter Purple for backgrounds/hovers */
            --md-green-500: #4CAF50;  /* Green for increases/logging */
            --md-green-700: #388E3C;
            --md-red-500: #f44336;    /* Red for decreases/danger */
            --md-red-700: #D32F2F;
            --md-grey-100: #f5f5f5;   /* Light grey for page background */
            --md-grey-300: #e0e0e0;   /* Borders */
            --md-grey-700: #616161;   /* Secondary text */
            --md-grey-900: #212121;   /* Primary text */
            --md-white: #FFFFFF;
            --md-elevation-1: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --md-elevation-2: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            --md-elevation-4: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
        }

        body { 
            font-family: 'Roboto', sans-serif; 
            margin: 0; 
            padding: 0; 
            background-color: var(--md-grey-100); 
            color: var(--md-grey-900); 
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            /* Mobile-first: no margin on small screens */
        }
        .app-container { 
            width: 100%;
            min-height: 100vh;
            background-color: var(--md-white); 
            overflow: hidden;
            /* Mobile-first: full width, add margins only on larger screens */
        }
        header { 
            background-color: var(--md-purple-700); 
            color: var(--md-white); 
            padding: 16px 20px; 
            text-align: center;
            /* Mobile-first: centered header */
        }
        header h1 { 
            margin: 0; 
            font-size: 1.4em; 
            font-weight: 500;
            /* Mobile-first: smaller size */
        }
        nav { 
            background-color: var(--md-purple-500); 
            box-shadow: var(--md-elevation-1);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            padding: 4px 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            /* Mobile-first: horizontal scrollable tabs */
        }
        nav button { 
            background-color: transparent; 
            color: var(--md-purple-100); 
            border: none; 
            padding: 12px 16px; 
            margin: 0; 
            border-radius: 0; 
            cursor: pointer; 
            font-size: 0.85em; 
            font-weight: 500;
            text-transform: uppercase;
            transition: background-color 0.2s, color 0.2s; 
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
            min-height: 44px; /* Touch target compliance */
        }
        nav button:hover { 
            background-color: rgba(255,255,255,0.1);
            color: var(--md-white);
        }
        nav button.active { 
            color: var(--md-white);
            border-bottom: 3px solid var(--md-white); /* Active tab indicator */
        }
        .content-area { 
            padding: 16px; 
            /* Mobile-first: smaller padding */
        }
        .tab-content { display: none; } 
        .tab-content.active { display: block; } 
        .section { 
            margin-bottom: 24px; 
            padding: 20px; 
            background-color: var(--md-white); 
            border-radius: 6px; 
            border: 1px solid var(--md-grey-300);
            box-shadow: var(--md-elevation-1);
        }
        .section h2 { 
            font-size: 1.6em; 
            color: var(--md-purple-700); 
            margin-top: 0; 
            margin-bottom: 16px;
            padding-bottom: 10px; 
            border-bottom: 2px solid var(--md-purple-100); 
            font-weight: 500;
        }
        .section h3 { 
            font-size: 1.3em; 
            color: var(--md-purple-500); 
            margin-top: 20px; 
            margin-bottom: 12px;
            font-weight: 500;
        }
        .section h4 { 
            font-size: 1.1em; 
            color: var(--md-grey-900); 
            margin-top: 16px; 
            margin-bottom: 8px;
            font-weight: 500;
        }
        .section ul { padding-left: 20px; margin-bottom: 16px; }
        .section li { margin-bottom: 10px; color: var(--md-grey-700); }
        
        label { 
            display: block; 
            margin-top: 12px; 
            margin-bottom: 4px;
            font-weight: 500; 
            color: var(--md-grey-700);
            font-size: 0.9em;
        }
        input[type="text"], input[type="number"], input[type="date"], select { 
            width: 100%; 
            padding: 14px; 
            margin-top: 4px; 
            border: 1px solid var(--md-grey-300); 
            border-radius: 6px; 
            box-sizing: border-box; 
            font-size: 16px; /* Prevents zoom on iOS */
            background-color: var(--md-white);
            color: var(--md-grey-900);
            transition: border-color 0.2s;
            /* Mobile-first: larger touch targets */
        }
        input[type="text"]:focus, input[type="number"]:focus, input[type="date"]:focus, select:focus {
            border-color: var(--md-purple-500);
            outline: none;
            box-shadow: 0 0 0 2px var(--md-purple-100);
        }

        .inline-inputs { 
            margin-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* Mobile-first: stack vertically */
        }
        .inline-inputs label { 
            display: block; 
            margin-bottom: 4px; 
            font-weight: 500; 
            font-size: 0.9em;
        }
        .inline-inputs input[type="number"], .inline-inputs input[type="text"] { 
            width: 100%; 
            margin-right: 0; 
            padding: 14px;
            font-size: 16px; /* Prevents zoom on iOS */
            /* Mobile-first: full width inputs */
        }
        
        button.action-button, button.log-set-button, button.danger-button {
            color: var(--md-white); 
            padding: 14px 20px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            margin-top: 12px; 
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            box-shadow: var(--md-elevation-1);
            transition: background-color 0.2s, box-shadow 0.2s;
            min-height: 48px; /* Touch target compliance */
            min-width: 48px;
            /* Mobile-first: larger touch targets */
        }
        button.action-button { background-color: var(--md-purple-500); }
        button.action-button:hover { background-color: var(--md-purple-700); box-shadow: var(--md-elevation-2); }
        
        button.log-set-button { background-color: var(--md-green-500); } 
        button.log-set-button:hover { background-color: var(--md-green-700); box-shadow: var(--md-elevation-2); }
        
        button.danger-button { background-color: var(--md-red-500); } 
        button.danger-button:hover { background-color: var(--md-red-700); box-shadow: var(--md-elevation-2); }

        .exercise-item { 
            border-bottom: 1px solid var(--md-grey-300); 
            padding-bottom: 16px; 
            margin-bottom: 16px; 
        }
        .exercise-item:last-child { border-bottom: none; }
        .exercise-details { font-size: 0.95em; color: var(--md-grey-700); margin-bottom: 8px; }
        .exercise-notes { 
            font-style: normal; 
            font-size: 0.9em; 
            color: var(--md-grey-700); 
            background-color: var(--md-purple-100); 
            padding: 10px; 
            border-radius: 4px; 
            margin-top: 8px;
            border-left: 3px solid var(--md-purple-500);
        }
        
        .e1rm-manage-section table { 
            width: 100%; 
            margin-top: 16px; 
            border-collapse: collapse; 
        }
        .e1rm-manage-section th, .e1rm-manage-section td { 
            border: 1px solid var(--md-grey-300); 
            padding: 12px; 
            text-align: left; 
            font-size: 0.95em;
        }
        .e1rm-manage-section th { 
            background-color: var(--md-purple-100); 
            color: var(--md-purple-700);
            font-weight: 500;
        }
        .e1rm-manage-section td input[type="number"] {
            padding: 8px;
            font-size: 0.95em;
            max-width: 100px; /* Ensure input doesn't get too wide */
        }
        .e1rm-change-indicator.increased { color: var(--md-green-500); margin-left: 5px; font-weight: bold;}
        .e1rm-change-indicator.decreased { color: var(--md-red-500); margin-left: 5px; font-weight: bold;}


        .workout-log-entry { 
            border: 1px solid var(--md-grey-300); 
            padding: 12px; 
            margin-top: 8px; 
            border-radius: 4px; 
            background-color: var(--md-white); 
            font-size: 0.9em; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        #dailyWorkoutLogContainer { 
            max-height: 250px; 
            overflow-y: auto; 
            margin-top:16px; 
            border: 1px solid var(--md-grey-300); 
            padding:10px; 
            background-color: var(--md-grey-100);
            border-radius: 4px;
        }
        .completed-marker { color: var(--md-green-500); font-weight: bold; margin-left: 10px; }
        
        .modal { 
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.6); 
            backdrop-filter: blur(4px);
            /* Mobile-first: full screen modal */
        }
        .modal-content { 
            background-color: var(--md-white); 
            margin: 0;
            padding: 20px; 
            border-radius: 0;
            width: 100%; 
            height: 100%;
            box-shadow: none;
            position: relative;
            overflow-y: auto;
            /* Mobile-first: full screen modal */
        }
        .close-button { 
            color: var(--md-grey-700); 
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 32px; 
            font-weight: bold; 
            cursor: pointer; 
            line-height: 1;
        }
        .close-button:hover, .close-button:focus { color: var(--md-grey-900); text-decoration: none; }
        .modal-content h3 { color: var(--md-purple-700); margin-top: 0; font-weight: 500; }
        .bodyweight-input-container { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--md-grey-300); }
        .bodyweight-input-container label { font-weight: 500; }
        .bodyweight-input-container input { max-width: 120px; display: inline-block; margin-right: 10px;}
        .metrics-input-group { display: flex; gap: 10px; align-items: flex-end; margin-bottom: 15px;}
        .metrics-input-group div { flex-grow: 1;}

        /* Tablet and larger screens - improve from mobile-first base */
        @media (min-width: 768px) {
            .app-container { 
                max-width: 900px;
                margin: 20px auto; 
                border-radius: 8px;
                box-shadow: var(--md-elevation-2);
            }
            .content-area { padding: 24px; }
            .section { 
                padding: 20px; 
                margin-bottom: 24px;
            }
            
            /* Desktop header - restore traditional layout */
            header {
                padding: 24px;
            }
            header h1 {
                font-size: 1.9em;
            }
            
            /* Hide hamburger menu on larger screens */
            .hamburger-menu {
                display: none !important;
            }
            
            /* Desktop navigation - horizontal layout */
            nav {
                padding: 8px 0;
                overflow-x: visible;
            }
            nav button {
                padding: 12px 18px;
                font-size: 0.98em;
            }
            
            /* Desktop modal - windowed instead of full screen */
            .modal-content { 
                margin: 10% auto;
                padding: 24px; 
                border-radius: 8px;
                width: 90%; 
                max-width: 500px; 
                height: auto;
                box-shadow: var(--md-elevation-4);
            }
            
            
            /* Inline inputs can be horizontal on larger screens */
            .inline-inputs {
                display: block;
                margin-bottom: 10px;
            }
            .inline-inputs label { 
                display: inline-block; 
                margin-right: 5px; 
                font-weight: normal; 
                font-size: 0.95em;
                margin-bottom: 0;
            }
            .inline-inputs input[type="number"], .inline-inputs input[type="text"] { 
                width: 75px; 
                display: inline-block; 
                margin-right: 12px; 
                padding: 8px;
                font-size: 1em;
            }
            
            /* Horizontal metrics input group on larger screens */
            .metrics-input-group {
                flex-direction: row;
                gap: 10px;
            }
        }

        @media (max-width: 480px) {
            header h1 { font-size: 1.3em; }
            nav button { 
                padding: 8px 10px;
                font-size: 0.8em;
                min-width: 80px;
            }
            .content-area { padding: 12px; }
            .section { padding: 12px; }
            
            /* Stack form elements vertically on very small screens */
            .bodyweight-input-container input {
                max-width: 100%;
                margin-bottom: 10px;
            }
            
            /* Smaller modal on tiny screens */
            .modal-content {
                margin: 2% auto;
                width: 98%;
                padding: 16px;
            }
            
        }

        /* Landscape tablet */
        @media (min-width: 769px) and (max-width: 1024px) {
            .app-container {
                margin: 15px auto;
                max-width: 95%;
            }
            .content-area { padding: 20px; }
        }

        /* Touch-friendly improvements for all mobile devices */
        @media (hover: none) {
            button:hover {
                background-color: inherit; /* Remove hover effects on touch devices */
            }
            nav button:hover {
                background-color: rgba(255,255,255,0.1);
            }
            button.action-button:hover { background-color: var(--md-purple-500); }
            button.log-set-button:hover { background-color: var(--md-green-500); }
            button.danger-button:hover { background-color: var(--md-red-500); }
        }

        /* Rest Timer Styles */
        .rest-timer-container {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--md-white);
            border: 2px solid var(--md-purple-500);
            border-radius: 8px;
            padding: 15px;
            box-shadow: var(--md-elevation-4);
            z-index: 999;
            min-width: 200px;
            text-align: center;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .rest-timer-container.active {
            transform: translateX(0);
        }
        .rest-timer-display {
            font-size: 2em;
            font-weight: bold;
            color: var(--md-purple-700);
            margin: 10px 0;
            font-family: 'Roboto Mono', monospace;
        }
        .rest-timer-controls {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .rest-timer-controls button {
            padding: 6px 12px;
            font-size: 0.85em;
            min-height: auto;
        }
        .timer-preset-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .timer-preset-buttons button {
            padding: 4px 8px;
            font-size: 0.75em;
            background-color: var(--md-grey-300);
            color: var(--md-grey-900);
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .timer-preset-buttons button:hover {
            background-color: var(--md-grey-700);
            color: var(--md-white);
        }

        @media (max-width: 768px) {
            .rest-timer-container {
                top: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
                padding: 12px;
            }
            .rest-timer-display {
                font-size: 1.8em;
            }
        }

        /* Analytics Styles */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background-color: var(--md-white);
            border: 1px solid var(--md-grey-300);
            border-radius: 6px;
            padding: 15px;
            text-align: center;
            box-shadow: var(--md-elevation-1);
        }
        
        .metric-card h4 {
            margin: 0 0 8px 0;
            color: var(--md-purple-700);
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
        }
        
        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            color: var(--md-grey-900);
            margin: 5px 0;
        }
        
        .metric-unit {
            font-size: 0.85em;
            color: var(--md-grey-700);
            margin-top: 2px;
        }
        
        .metric-trend {
            font-size: 0.8em;
            margin-top: 5px;
        }
        
        .metric-trend.positive {
            color: var(--md-green-500);
        }
        
        .metric-trend.negative {
            color: var(--md-red-500);
        }
        
        .metric-trend.neutral {
            color: var(--md-grey-700);
        }
        
        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }
            
            .metric-card {
                padding: 12px;
            }
            
            .metric-value {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <h1>My Training Plan</h1>
        </header>
        <nav id="mainNav">
            <button data-tab="guideTab" onclick="showTab('guideTab')">Guide</button>
            <button data-tab="smartRecommendationsTab" onclick="showTab('smartRecommendationsTab')">Smart Recommendations</button>
                    <button data-tab="analyticsTab" onclick="showTab('analyticsTab')">Analytics</button>
            <button data-tab="e1rmTab" onclick="showTab('e1rmTab')">Settings &amp; e1RMs</button>
        </nav>
        <div class="content-area">
            <div id="guideTab" class="tab-content section">
                <h2>Program Guide</h2>
                <p>Welcome to your personalized strength and conditioning plan tracker! This guide will help you understand how to use the app and follow the program effectively.</p>

                <h4>Core Principles:</h4>
                <ul>
                    <li><strong>Consistency is Key:</strong> Adherence to the plan over time will yield the best results. Show up and do the work.</li>
                    <li><strong>Progressive Overload:</strong> The program is designed to help you gradually get stronger. This app helps by:
                        <ul>
                            <li>Calculating target weights based on your e1RM.</li>
                            <li>Autoregulating your e1RM based on your performance (especially on heavy single sets). Aim to improve weight, reps, or perform sets at a lower RPE over time.</li>
                        </ul>
                    </li>
                    <li><strong>RPE (Rating of Perceived Exertion):</strong>
                        <ul>
                            <li>Scale of 1-10, where 10 is maximal effort (0 reps left), 9 is 1 rep left (RIR 1), 8 is 2 reps left (RIR 2), etc.</li>
                            <li>Use RPE honestly to guide your effort and help the app adjust your e1RM.</li>
                            <li>Your plan often specifies target RPEs for activation and top sets (e.g., RPE 8-9).</li>
                        </ul>
                    </li>
                    <li><strong>e1RM (Estimated 1 Rep Max):</strong>
                        <ul>
                            <li>This is an estimate of the maximum weight you can lift for one repetition.</li>
                            <li>Set your initial e1RMs and Bodyweight in the "Settings &amp; e1RMs" tab.</li>
                            <li>The app updates your e1RM for main lifts after you log "Activation Sets" and "Main Top Sets". The highest calculated e1RM from these sets in a session becomes your new e1RM for that lift.</li>
                            <li>Accessory lifts that are also in the `CORE_LIFTS_IN_PLAN` list can also have their e1RMs updated if a logged set represents a new PR.</li>
                            <li>For bodyweight exercises like Dips and Weighted Pull-ups, the weight you log is *added weight*. The app uses your set bodyweight + added weight to calculate the e1RM (total load).</li>
                        </ul>
                    </li>
                </ul>

                <h4>Workout Structure:</h4>
                <ul>
                    <li><strong>Activation Sets (&gt;90% 1RM):</strong> Perform 1 set of 3-5 reps. These prepare you for heavy lifting, allow practice with heavy loads, and contribute to e1RM updates.</li>
                    <li><strong>Main Top Sets (e.g., 1x4 @ 88%):</strong> Your primary strength-building set for the main compound lifts. These also significantly contribute to e1RM updates.</li>
                    <li><strong>Volume Sets (e.g., 3x6 @ 78%):</strong> Build muscle mass and work capacity. Target weights are based on the e1RM at the start of the session.</li>
                    <li><strong>Accessory Lifts:</strong> Target specific muscle groups and support your main lifts. Aim for the prescribed reps/sets and an appropriate RPE (often 7-9).</li>
                    <li><strong>Cardio (HIIT &amp; Zone 2):</strong> Crucial for cardiovascular health (VO<sub>2</sub>max) and endurance.
                        <ul>
                            <li>HIIT (e.g., Norwegian 4x4): Intense intervals.</li>
                            <li>Zone 2: Longer, steady-state cardio at a conversational pace (~70% HRmax or RPE 9-12).</li>
                        </ul>
                    </li>
                    <li><strong>Mobility:</strong> Focus on dynamic movements. Resistance training itself helps maintain flexibility.</li>
                </ul>

                <h4>Warm-ups &amp; Rest:</h4>
                <ul>
                    <li><strong>Warm-ups:</strong> Perform dynamic, lift-specific warm-ups. Your plan mentions mini-band glute activation (Mon) and shoulder ER (Tue). One or two ramp-up sets for main lifts usually suffice.</li>
                    <li><strong>Rest Periods:</strong>
                        <ul>
                            <li>After Activation/Main Top Sets: 2-5 minutes.</li>
                            <li>Between Volume Sets: 2-3 minutes.</li>
                            <li>Between Accessory Sets: As needed, typically 60-120 seconds.</li>
                        </ul>
                    </li>
                </ul>
                <h4>Nutrition &amp; Lifestyle (From Your Plan):</h4>
                <ul>
                    <li><strong>Protein:</strong> 1.6–2.2 g/kg/day (≥ 0.4 g/kg/meal).</li>
                    <li><strong>Creatine Monohydrate:</strong> 3–5 g daily.</li>
                    <li><strong>Omega‑3:</strong> Load 4 wks @ 3g EPA + 2g DHA, then ~2g total daily.</li>
                    <li><strong>Calorie Balance:</strong> For recomp, maintain ≈10‑15 % kcal deficit with high protein.</li>
                    <li><strong>Sleep:</strong> 7–9 hours; crucial for recovery and body composition.</li>
                </ul>

                <h4>How to Use This App:</h4>
                <ol>
                    <li><strong>Set Initial e1RMs &amp; Bodyweight:</strong> Go to the "Settings &amp; e1RMs" tab. Input your current bodyweight and estimated 1 Rep Max for all listed exercises. Click "Save All Settings &amp; e1RMs". This is crucial for the app to calculate your target weights and track bodyweight exercises accurately.</li>
                    <li><strong>Choose Your Workout:</strong> Click any workout type in the top navigation (e.g., "Squat Day", "Bench Day", "Deadlift Day"). You can do these workouts on any day of the week that works for your schedule. <em>NEW: Use the "Smart Recommendations" tab to get AI-powered workout suggestions based on how you're feeling and your recent training history!</em></li>
                    <li><strong>Perform &amp; Log:</strong>
                        <ul>
                            <li>For each exercise, the app will show target weights (if applicable).</li>
                            <li>For bodyweight exercises like Dips and Pull-ups, the "Actual Wt" field in the modal refers to *added weight*.</li>
                            <li>After performing a set, enter the actual weight lifted (or added weight), reps performed, and RPE achieved.</li>
                            <li>Click the "Log Set" button.</li>
                            <li>For multi-set accessory exercises, a modal will appear for logging each set.</li>
                            <li>For mobility/cardio, click "Mark Completed".</li>
                        </ul>
                    </li>
                    <li><strong>Track Progress:</strong> Visit the "Progress" tab to see your bodyweight graph and weekly workout days logged.</li>
                    <li><strong>Review:</strong> Check "Today's Log" to see your completed activities and any e1RM updates. Your e1RMs in the "Settings &amp; e1RMs" tab will also reflect changes.</li>
                </ol>
                
                <h4>Workout Types:</h4>
                <ul>
                    <li><strong>Squat Day:</strong> Focus on back squats with hip thrust accessory work</li>
                    <li><strong>Bench Day:</strong> Bench press with overhead press and dips</li>
                    <li><strong>Deadlift Day:</strong> Deadlifts with Romanian deadlift accessory work</li>
                    <li><strong>Pull Day:</strong> Weighted pull-ups, rows, and HIIT cardio</li>
                    <li><strong>Cardio Day:</strong> Zone 2 cardiovascular training</li>
                    <li><strong>Mobility Day:</strong> Dynamic movement and flexibility work</li>
                    <li><strong>Rest Day:</strong> Light mobility and recovery</li>
                </ul>
                <p><em>This app uses your browser's local storage to save data. It will persist as long as you use the same browser and don't clear its site data.</em></p>
            </div>

            <div id="smartRecommendationsTab" class="tab-content section">
                <h2>Smart Workout Recommendations</h2>
                <p>Get AI-powered workout recommendations based on your training history, current fitness level, and how you're feeling today.</p>
                
                <div class="section">
                    <h3>How are you feeling today?</h3>
                    <div style="margin-bottom: 15px;">
                        <label for="energyLevel">Energy Level (1-10):</label>
                        <input type="range" id="energyLevel" min="1" max="10" value="7" style="width: 100%; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.8em; color: var(--md-grey-700);">
                            <span>Very Low</span>
                            <span id="energyLevelValue">7</span>
                            <span>Very High</span>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="stressLevel">Stress Level (1-10):</label>
                        <input type="range" id="stressLevel" min="1" max="10" value="5" style="width: 100%; margin: 10px 0;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.8em; color: var(--md-grey-700);">
                            <span>Very Low</span>
                            <span id="stressLevelValue">5</span>
                            <span>Very High</span>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="musclesSore">Any muscle soreness or fatigue?</label>
                        <textarea id="musclesSore" placeholder="e.g., legs still sore from yesterday's squat session, feeling fresh overall, shoulders tight..." style="width: 100%; padding: 10px; border: 1px solid var(--md-grey-300); border-radius: 4px; box-sizing: border-box;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="timeAvailable">Time available (minutes):</label>
                        <input type="number" id="timeAvailable" value="60" min="15" max="180" style="width: 100px;">
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="specificGoals">Specific goals for today (optional):</label>
                        <textarea id="specificGoals" placeholder="e.g., want to focus on upper body, need a lighter day, want to push hard today..." style="width: 100%; padding: 10px; border: 1px solid var(--md-grey-300); border-radius: 4px; box-sizing: border-box;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="equipmentLimitations">Equipment limitations (optional):</label>
                        <textarea id="equipmentLimitations" placeholder="e.g., no barbell today, only dumbbells, home gym setup, no squat rack..." style="width: 100%; padding: 10px; border: 1px solid var(--md-grey-300); border-radius: 4px; box-sizing: border-box;"></textarea>
                    </div>
                    
                    <button class="action-button" onclick="getWorkoutRecommendation()" id="getRecommendationBtn">Get AI Recommendation</button>
                    <button class="action-button" onclick="generateSimpleRecommendation()" style="margin-left: 10px;">Get Quick Recommendation</button>
                </div>
                
                <div id="recommendationResult" class="section" style="display: none;">
                    <h3>Your Recommended Workout</h3>
                    <div id="recommendationContent"></div>
                    <button class="action-button" onclick="acceptRecommendation()" id="acceptRecommendationBtn" style="margin-top: 15px;">Start This Workout</button>
                </div>
            </div>

            <div id="workoutDayTab" class="tab-content">
                <div id="workoutDisplayArea" class="section">
                    <h2 id="workoutDayTitle">Select a day</h2>
                    <!-- Workout items will be populated here by JavaScript -->
                </div>

                <div class="section">
                    <h2>Today's Log (<span id="currentDateDisplay"></span>)</h2>
                    <div id="dailyWorkoutLogContainer"></div>
                    <button class="danger-button" onclick="clearDailyLog()" style="margin-top:10px;">Clear Today's Log</button>
                </div>
            </div>
            

            <div id="analyticsTab" class="tab-content section">
                <h2>Analytics &amp; Progress Tracking</h2>
                
                <!-- Attendance Section -->
                <div class="section">
                    <h3>Attendance</h3>
                    <p id="attendanceSummary">Workout days this week: 0</p>
                </div>

                <!-- Bodyweight Tracking Section -->
                <div class="section">
                    <h3>Bodyweight Tracking</h3>
                    <div class="metrics-input-group">
                        <div>
                            <label for="logBodyweightDate">Date:</label>
                            <input type="date" id="logBodyweightDate">
                        </div>
                        <div>
                            <label for="logBodyweightValue">Bodyweight (kg/lbs):</label>
                            <input type="number" id="logBodyweightValue" placeholder="e.g., 70.5">
                        </div>
                        <button class="action-button" onclick="logBodyweightEntryFromInput()" style="align-self: flex-end; margin-bottom:0; padding: 12px 18px;">Log BW Entry</button>
                    </div>
                    <canvas id="bodyweightChart" style="max-height: 300px;"></canvas>
                </div>
                
                <!-- Volume Tracking Section -->
                <div class="section">
                    <h3>Volume Tracking</h3>
                    <div style="margin-bottom: 15px;">
                        <label for="volumeTimeRange">Time Period:</label>
                        <select id="volumeTimeRange" onchange="updateVolumeAnalytics()" style="margin-left: 10px; padding: 5px;">
                            <option value="7">Last 7 days</option>
                            <option value="14">Last 14 days</option>
                            <option value="30" selected>Last 30 days</option>
                            <option value="90">Last 90 days</option>
                        </select>
                    </div>
                    <canvas id="volumeChart" style="max-height: 300px; margin-bottom: 15px;"></canvas>
                    <div id="volumeMetrics" class="metrics-grid">
                        <!-- Volume metrics will be populated here -->
                    </div>
                </div>

                <!-- Strength Progression Section -->
                <div class="section">
                    <h3>Strength Progression</h3>
                    <div style="margin-bottom: 15px;">
                        <label for="strengthExercise">Exercise:</label>
                        <select id="strengthExercise" onchange="updateStrengthChart()" style="margin-left: 10px; padding: 5px;">
                            <option value="Back-squat">Back Squat</option>
                            <option value="Bench Press">Bench Press</option>
                            <option value="Deadlift">Deadlift</option>
                            <option value="OHP">Overhead Press</option>
                            <option value="Weighted Pull-up">Weighted Pull-up</option>
                            <option value="Hip-thrust">Hip Thrust</option>
                            <option value="RDL">Romanian Deadlift</option>
                            <option value="Dips">Dips</option>
                            <option value="Chest-supported Row">Chest-supported Row</option>
                        </select>
                        <label for="strengthTimeRange" style="margin-left: 20px;">Time Period:</label>
                        <select id="strengthTimeRange" onchange="updateStrengthChart()" style="margin-left: 10px; padding: 5px;">
                            <option value="30">Last 30 days</option>
                            <option value="60">Last 60 days</option>
                            <option value="90" selected>Last 90 days</option>
                            <option value="180">Last 6 months</option>
                            <option value="365">Last year</option>
                        </select>
                    </div>
                    <canvas id="strengthChart" style="max-height: 300px; margin-bottom: 15px;"></canvas>
                    <div id="strengthMetrics" class="metrics-grid">
                        <!-- Strength metrics will be populated here -->
                    </div>
                </div>

                <!-- Training Load Section -->
                <div class="section">
                    <h3>Training Load &amp; RPE Analysis</h3>
                    <div style="margin-bottom: 15px;">
                        <label for="loadTimeRange">Time Period:</label>
                        <select id="loadTimeRange" onchange="updateTrainingLoadAnalytics()" style="margin-left: 10px; padding: 5px;">
                            <option value="7">Last 7 days</option>
                            <option value="14">Last 14 days</option>
                            <option value="30" selected>Last 30 days</option>
                        </select>
                    </div>
                    <canvas id="trainingLoadChart" style="max-height: 300px; margin-bottom: 15px;"></canvas>
                    <div id="trainingLoadMetrics" class="metrics-grid">
                        <!-- Training load metrics will be populated here -->
                    </div>
                </div>

                <!-- Performance Metrics Section -->
                <div class="section">
                    <h3>Performance Metrics</h3>
                    <div id="performanceMetrics" class="metrics-grid">
                        <!-- Performance metrics will be populated here -->
                    </div>
                </div>

                <!-- Frequency Tracking Section -->
                <div class="section">
                    <h3>Training Frequency</h3>
                    <canvas id="frequencyChart" style="max-height: 300px; margin-bottom: 15px;"></canvas>
                    <div id="frequencyMetrics" class="metrics-grid">
                        <!-- Frequency metrics will be populated here -->
                    </div>
                </div>
            </div>

            <div id="e1rmTab" class="tab-content section e1rm-manage-section">
                <h2>Settings &amp; e1RMs</h2>
                <div class="bodyweight-input-container">
                    <label for="currentBodyweight">Current Bodyweight for Calculations (kg/lbs):</label>
                    <input type="number" id="currentBodyweight" placeholder="e.g., 70">
                    <span style="font-size:0.85em; color: var(--md-grey-700); display:block; margin-top:4px;">This is used for e1RM calculations on bodyweight exercises. Log historical bodyweight in the 'Progress' tab.</span>
                </div>
                <div class="bodyweight-input-container">
                    <label for="claudeApiKey">Claude API Key (Optional - for workout recommendations):</label>
                    <input type="password" id="claudeApiKey" placeholder="sk-ant-...">
                    <div style="margin-top: 8px;">
                        <button class="action-button" onclick="saveClaudeApiKey()" style="padding: 8px 12px; font-size: 0.9em; margin-right: 8px;">Save API Key</button>
                        <button class="action-button" onclick="testClaudeApiKey()" style="padding: 8px 12px; font-size: 0.9em;">Test API Key</button>
                    </div>
                    <span style="font-size:0.85em; color: var(--md-grey-700); display:block; margin-top:4px;">Enter your Claude API key to enable AI-powered workout recommendations based on your history and how you're feeling.</span>
                    <div id="apiKeyStatus" style="font-size: 0.85em; margin-top: 4px;"></div>
                </div>
                <div class="bodyweight-input-container">
                    <h3>Data Management</h3>
                    
                    <!-- Advanced Export Section -->
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; color: var(--md-blue-600);">Export Options</h4>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                            <button class="action-button" onclick="exportData()">Export All Data (JSON)</button>
                            <button class="action-button" onclick="exportDataCSV()">Export All Data (CSV)</button>
                            <button class="action-button" onclick="showSelectiveExportModal()">Selective Export</button>
                        </div>
                    </div>

                    <!-- Import Section -->
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; color: var(--md-green-600);">Import Options</h4>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                            <button class="action-button" onclick="document.getElementById('importFile').click()">Import Data</button>
                            <button class="action-button" onclick="validateDataIntegrity()">Validate Data</button>
                            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
                        </div>
                    </div>

                    <!-- Backup Management -->
                    <div style="margin-bottom: 20px;">
                        <h4 style="margin-bottom: 10px; color: var(--md-orange-600);">Backup Management</h4>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                            <button class="action-button" onclick="createAutoBackup()">Create Auto Backup</button>
                            <button class="action-button" onclick="showBackupHistory()">Backup History</button>
                        </div>
                    </div>

                </div>
                
                <h3>Manage e1RMs (kg/lbs)</h3>
                <table>
                    <thead><tr><th>Exercise</th><th>Current e1RM <span style="font-size:0.8em; font-weight:normal;">(Change)</span></th><th>New e1RM (Editable)</th></tr></thead>
                    <tbody id="e1rmTableBody"></tbody>
                </table>
                <button id="saveAllE1RMsButton" class="action-button" onclick="saveAllSettingsAndE1RMs()">Save All Settings &amp; e1RMs</button>
            </div>
        </div>
    </div>

    <div id="accessoryLogModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <h3 id="modalTitle">Log Accessory Set</h3>
            <input type="hidden" id="modalExerciseName">
            <input type="hidden" id="modalSetIndex">
            <label for="modalWeight" id="modalWeightLabel">Weight:</label>
            <input type="number" id="modalWeight" placeholder="Weight">
            <label for="modalReps">Reps:</label>
            <input type="number" id="modalReps" placeholder="Reps">
            <label for="modalRPE">RPE (6-10):</label>
            <input type="number" id="modalRPE" step="0.5" min="6" max="10" placeholder="RPE">
            <button class="action-button" onclick="submitAccessorySetLog()">Log Set</button>
        </div>
    </div>

    <!-- Selective Export Modal -->
    <div id="selectiveExportModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeSelectiveExportModal()">&times;</span>
            <h3>Selective Data Export</h3>
            
            <div style="margin-bottom: 20px;">
                <h4>Export Format</h4>
                <label><input type="radio" name="exportFormat" value="json" checked> JSON</label>
                <label style="margin-left: 15px;"><input type="radio" name="exportFormat" value="csv"> CSV</label>
            </div>

            <div style="margin-bottom: 20px;">
                <h4>Data Categories</h4>
                <label><input type="checkbox" id="exportE1RMs" checked> Exercise 1RMs</label><br>
                <label><input type="checkbox" id="exportBodyweight" checked> Bodyweight History</label><br>
                <label><input type="checkbox" id="exportWorkouts" checked> Workout Logs</label><br>
                <label><input type="checkbox" id="exportSettings" checked> Settings & API Key</label>
            </div>

            <div style="margin-bottom: 20px;">
                <h4>Date Range (for Workout Logs)</h4>
                <label for="exportStartDate">Start Date:</label>
                <input type="date" id="exportStartDate"><br>
                <label for="exportEndDate">End Date:</label>
                <input type="date" id="exportEndDate">
            </div>

            <div style="margin-bottom: 20px;">
                <h4>Specific Exercises (for e1RMs)</h4>
                <div id="exerciseCheckboxes" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--md-grey-300); padding: 10px; border-radius: 4px;">
                    <!-- Will be populated dynamically -->
                </div>
                <button type="button" onclick="selectAllExercises()" style="margin-top: 5px; font-size: 0.8em;">Select All</button>
                <button type="button" onclick="deselectAllExercises()" style="margin-left: 10px; font-size: 0.8em;">Deselect All</button>
            </div>

            <button class="action-button" onclick="executeSelectiveExport()">Export Selected Data</button>
        </div>
    </div>

    <!-- Rest Timer -->
    <div id="restTimer" class="rest-timer-container">
        <div style="font-size: 0.9em; font-weight: 500; margin-bottom: 8px;">Rest Timer</div>
        <div class="timer-preset-buttons">
            <button onclick="startRestTimer(60)">1m</button>
            <button onclick="startRestTimer(90)">1.5m</button>
            <button onclick="startRestTimer(120)">2m</button>
            <button onclick="startRestTimer(180)">3m</button>
            <button onclick="startRestTimer(300)">5m</button>
        </div>
        <div class="rest-timer-display" id="timerDisplay">0:00</div>
        <div class="rest-timer-controls">
            <button class="action-button" onclick="startRestTimer()" id="startTimerBtn">Start</button>
            <button class="action-button" onclick="pauseRestTimer()" id="pauseTimerBtn">Pause</button>
            <button class="action-button" onclick="stopRestTimer()" id="stopTimerBtn">Stop</button>
            <button class="action-button" onclick="toggleRestTimer()" id="toggleTimerBtn">Hide</button>
        </div>
        <div style="margin-top: 8px;">
            <input type="number" id="customTimerMinutes" placeholder="Minutes" style="width: 60px; padding: 4px; font-size: 0.8em;" min="0" max="60">
            <button class="action-button" onclick="startCustomTimer()" style="padding: 4px 8px; font-size: 0.8em;">Set</button>
        </div>
    </div>

    <script>
        // RPE to Reps In Reserve mapping
        const RPE_TO_RIR = { 10: 0, 9.5: 0.5, 9: 1, 8.5: 1.5, 8: 2, 7.5: 2.5, 7: 3, 6.5: 3.5, 6: 4 };
        // Core lifts for which e1RM will be tracked
        const CORE_LIFTS_IN_PLAN = ["Back-squat", "Bench Press", "Deadlift", "OHP", "Weighted Pull-up", "Hip-thrust", "RDL", "Dips", "Chest-supported Row"];
        const BODYWEIGHT_ASSISTED_EXERCISES = ["Weighted Pull-up", "Dips"]; 

        // The user's workout plan structure - reorganized by workout type
        const USER_WORKOUT_PLAN = {
            "Squat Day": [
                { id:"squat_activation", type: "strength_single_heavy", liftName: "Back-squat", sets: 1, repsTarget: 3, percentage: 0.92, group:"Back-squat", setLabel: "Activation Set (>90% 1RM)", notes: "Warm-up: Mini-band glute activation. Aim for 3-5 reps. RPE ~8.5-9.5. This set contributes to e1RM." },
                { id:"squat_top", type: "strength_single_heavy", liftName: "Back-squat", sets: 1, repsTarget: 4, percentage: 0.88, group:"Back-squat", setLabel: "Main Top Set", notes: "Rest 2-5 min after this set. Aim for RPE ~8-9. This set contributes to e1RM." },
                { id:"squat_vol", type: "strength_volume", liftName: "Back-squat", sets: 3, reps: 6, percentage: 0.78, group:"Back-squat", notes: "Rest 2-3 min between sets." },
                { id:"squat_ht", type: "accessory", liftName: "Hip-thrust", sets: 4, reps: 8, notes: "Aim for RPE 7-9." }
            ],
            "Bench Day": [
                { id:"bench_activation", type: "strength_single_heavy", liftName: "Bench Press", sets: 1, repsTarget: 3, percentage: 0.92, group:"Bench Press", setLabel: "Activation Set (>90% 1RM)", notes: "Warm-up: Shoulder ER. Aim for 3-5 reps. RPE ~8.5-9.5. This set contributes to e1RM." },
                { id:"bench_top", type: "strength_single_heavy", liftName: "Bench Press", sets: 1, repsTarget: 4, percentage: 0.88, group:"Bench Press", setLabel: "Main Top Set", notes: "Rest 2-5 min after this set. Aim for RPE ~8-9. This set contributes to e1RM." },
                { id:"bench_vol", type: "strength_volume", liftName: "Bench Press", sets: 3, reps: 6, percentage: 0.78, group:"Bench Press", notes: "Rest 2-3 min between sets." },
                { id:"bench_ohp", type: "accessory", liftName: "OHP", sets: 3, reps: 6, notes: "Aim for RPE 7-9. This lift also uses e1RM." },
                { id:"bench_dips", type: "accessory", liftName: "Dips", sets: 3, reps: 10, notes: "Aim for RPE 7-9, or near failure if appropriate. Log ADDED weight." }
            ],
            "Deadlift Day": [
                { id:"deadlift_activation", type: "strength_single_heavy", liftName: "Deadlift", sets: 1, repsTarget: 3, percentage: 0.92, group:"Deadlift", setLabel: "Activation Set (>90% 1RM)", notes: "Aim for 3-5 reps. RPE ~8.5-9.5. This set contributes to e1RM." },
                { id:"deadlift_top", type: "strength_single_heavy", liftName: "Deadlift", sets: 1, repsTarget: 3, percentage: 0.90, group:"Deadlift", setLabel: "Main Top Set", notes: "Rest 2-5 min after this set. Aim for RPE ~8-9. This set contributes to e1RM." },
                { id:"deadlift_vol", type: "strength_volume", liftName: "Deadlift", sets: 3, reps: 6, percentage: 0.80, group:"Deadlift", notes: "Rest 2-3 min between sets." },
                { id:"deadlift_rdl", type: "accessory", liftName: "RDL", sets: 3, reps: 8, notes: "Aim for RPE 7-9." }
            ],
            "Pull Day": [
                { id:"pull_hiit", type: "hiit", name: "Norwegian 4x4", details: "4 min @ 85-95% HRmax / 3 min active recovery @ ~70% HRmax, x4 repeats. Total duration approx 38-40min incl warm-up/cool-down.", notes: "Optional: 10-min HIIT (10x60s @ 90% HRmax / 60s easy) every 2-3 weeks for variety. Largest VO2-max gains." },
                { id:"pull_pullup", type: "accessory", liftName: "Weighted Pull-up", sets: 3, repsRange: "6-8", notes: "Aim for RPE 8-9. This lift uses e1RM. Log ADDED weight." },
                { id:"pull_row", type: "accessory", liftName: "Chest-supported Row", sets: 3, reps: 10, notes: "Aim for RPE 7-9." }
            ],
            "Cardio Day": [ 
                { id:"cardio_z2", type: "cardio", name: "Zone 2 Run", duration: "40-45 min", intensity: "~70% HRmax or RPE 9-12 (able to speak in sentences).", notes: "Consider extending to 60+ min for enhanced heart health benefits. Dynamic mobility is enough; resistance training itself maintains flexibility." } 
            ],
            "Mobility Day": [ 
                { id:"mobility_flow", type: "mobility", name: "Mobility Flow", notes: "Dynamic movements. Static stretching generally not needed if resistance training covers range of motion. Refer to §5 of your plan." } 
            ],
            "Rest Day": [ 
                { id:"rest_mobility", type: "mobility", name: "Rest + Short Mobility", notes: "Focus on recovery. Gentle movements." } 
            ]
        };

        // Global state variables
        let exercisesE1RM = {}; 
        let e1RMChangeStatus = {}; 
        let userBodyweight = 0; 
        let bodyweightHistory = []; // Array of {date: "YYYY-MM-DD", weight: number}
        
        
        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                const swCode = `
                    const CACHE_NAME = 'strength-tracker-v1';
                    const urlsToCache = ['/'];
                    
                    self.addEventListener('install', function(event) {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(function(cache) {
                                    return cache.addAll(urlsToCache);
                                })
                        );
                    });
                    
                    self.addEventListener('fetch', function(event) {
                        event.respondWith(
                            caches.match(event.request)
                                .then(function(response) {
                                    if (response) {
                                        return response;
                                    }
                                    return fetch(event.request);
                                })
                        );
                    });
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then(function(registration) {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(function(err) {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
        
        let dailyLog = {};      
        let currentSelectedDayKey = null; 
        let currentActiveTab = 'guideTab'; 
        const APP_VERSION_KEY = 'v4_material_bw_graph'; // Updated version key
        const todayKey = new Date().toISOString().split('T')[0]; 
        let bodyweightChartInstance = null;
        let claudeApiKey = '';
        let currentRecommendation = null;
        
        // Rest Timer Variables
        let restTimerInterval = null;
        let restTimerSeconds = 0;
        let restTimerTotalSeconds = 0;
        let restTimerPaused = false;


        // Epley formula for e1RM calculation
        function calculateEpleyE1RM(weight, reps) {
            if (reps === 0 || weight === 0) return 0; 
            if (reps === 1) return weight; 
            return weight * (1 + (reps / 30));
        }

        // Calculates effective reps based on actual reps and RPE (using RIR)
        function getEffectiveReps(actualReps, actualRPE) {
            let effectiveReps = parseFloat(actualReps);
            if (RPE_TO_RIR.hasOwnProperty(actualRPE)) {
                effectiveReps += RPE_TO_RIR[actualRPE];
            } else if (actualRPE < 6) { 
                effectiveReps += (10 - actualRPE);
            }
            return effectiveReps;
        }
        
        // Enhanced error handling with user feedback
        function showError(message, details = '') {
            console.error('App Error:', message, details);
            const alertMessage = `Error: ${message}${details ? '\n\nDetails: ' + details : ''}`;
            alert(alertMessage);
        }

        function showSuccess(message) {
            console.log('Success:', message);
            // Could be enhanced with a toast notification system
        }

        // Load data from localStorage with error handling
        function loadData() {
            try {
                const storedE1RMs = localStorage.getItem(`personalizedPlanE1RMs_${APP_VERSION_KEY}`); 
                if (storedE1RMs) {
                    exercisesE1RM = JSON.parse(storedE1RMs);
                    // Validate loaded data
                    if (typeof exercisesE1RM !== 'object' || exercisesE1RM === null) {
                        throw new Error('Invalid e1RM data format');
                    }
                } else { 
                    CORE_LIFTS_IN_PLAN.forEach(lift => exercisesE1RM[lift] = 0); 
                }
            } catch (error) {
                showError('Failed to load e1RM data', error.message);
                CORE_LIFTS_IN_PLAN.forEach(lift => exercisesE1RM[lift] = 0);
            }
            
            try {
                const storedChangeStatus = localStorage.getItem(`personalizedPlanE1RMChangeStatus_${APP_VERSION_KEY}`);
                if (storedChangeStatus) {
                    e1RMChangeStatus = JSON.parse(storedChangeStatus);
                } else {
                    e1RMChangeStatus = {};
                }
            } catch (error) {
                showError('Failed to load e1RM change status', error.message);
                e1RMChangeStatus = {};
            }

            try {
                const storedBodyweight = localStorage.getItem(`personalizedPlanBodyweight_${APP_VERSION_KEY}`);
                if (storedBodyweight) {
                    userBodyweight = parseFloat(storedBodyweight);
                    if (isNaN(userBodyweight) || userBodyweight <= 0) {
                        throw new Error('Invalid bodyweight value');
                    }
                    document.getElementById('currentBodyweight').value = userBodyweight;
                }
            } catch (error) {
                showError('Failed to load bodyweight', error.message);
                userBodyweight = 0;
            }

            try {
                const storedBwHistory = localStorage.getItem(`personalizedPlanBwHistory_${APP_VERSION_KEY}`);
                if (storedBwHistory) {
                    bodyweightHistory = JSON.parse(storedBwHistory);
                    if (!Array.isArray(bodyweightHistory)) {
                        throw new Error('Invalid bodyweight history format');
                    }
                } else {
                    bodyweightHistory = [];
                }
            } catch (error) {
                showError('Failed to load bodyweight history', error.message);
                bodyweightHistory = [];
            }

            try {
                const storedApiKey = localStorage.getItem(`personalizedPlanClaudeApiKey_${APP_VERSION_KEY}`);
                if (storedApiKey) {
                    claudeApiKey = storedApiKey;
                    document.getElementById('claudeApiKey').value = claudeApiKey;
                }
            } catch (error) {
                showError('Failed to load API key', error.message);
                claudeApiKey = '';
            }

            try {
                const storedDailyLog = localStorage.getItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${todayKey}`); 
                if (storedDailyLog) {
                    dailyLog = JSON.parse(storedDailyLog);
                    if (typeof dailyLog !== 'object' || dailyLog === null) {
                        throw new Error('Invalid daily log format');
                    }
                } else {
                    dailyLog = {}; 
                }
            } catch (error) {
                showError('Failed to load daily log', error.message);
                dailyLog = {};
            }
        }

        // Save data to localStorage with error handling
        function saveData() {
            try {
                localStorage.setItem(`personalizedPlanE1RMs_${APP_VERSION_KEY}`, JSON.stringify(exercisesE1RM));
                localStorage.setItem(`personalizedPlanE1RMChangeStatus_${APP_VERSION_KEY}`, JSON.stringify(e1RMChangeStatus));
                localStorage.setItem(`personalizedPlanBodyweight_${APP_VERSION_KEY}`, userBodyweight.toString());
                localStorage.setItem(`personalizedPlanBwHistory_${APP_VERSION_KEY}`, JSON.stringify(bodyweightHistory));
                localStorage.setItem(`personalizedPlanClaudeApiKey_${APP_VERSION_KEY}`, claudeApiKey);
                localStorage.setItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${todayKey}`, JSON.stringify(dailyLog));
            } catch (error) {
                showError('Failed to save data', error.message + '. Your data may not be preserved.');
            }
        }
        
        // Saves the current bodyweight from the settings tab and logs it.
        function saveCurrentBodyweightAndLog() {
            const bwInput = document.getElementById('currentBodyweight');
            const newBw = parseFloat(bwInput.value);
            if (!isNaN(newBw) && newBw > 0) {
                userBodyweight = newBw;
                logBodyweightEntry(todayKey, newBw, false); // Log it, don't show alert from here
                // saveData() will be called by saveAllSettingsAndE1RMs
            } else {
                // Don't alert here, saveAllSettingsAndE1RMs will handle general save.
            }
        }
        
        // Logs a bodyweight entry from the Progress tab
        function logBodyweightEntryFromInput() {
            const dateInput = document.getElementById('logBodyweightDate').value;
            const weightInput = parseFloat(document.getElementById('logBodyweightValue').value);

            if (!dateInput) {
                alert("Please select a date.");
                return;
            }
            if (isNaN(weightInput) || weightInput <= 0) {
                alert("Please enter a valid bodyweight.");
                return;
            }
            logBodyweightEntry(dateInput, weightInput, true);
            document.getElementById('logBodyweightValue').value = ''; // Clear input
        }

        // Core function to log bodyweight, updates history and chart
        function logBodyweightEntry(date, weight, showAlert = true) {
            // Remove any existing entry for the same date to avoid duplicates, then add new one
            bodyweightHistory = bodyweightHistory.filter(entry => entry.date !== date);
            bodyweightHistory.push({ date: date, weight: parseFloat(weight) });
            bodyweightHistory.sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date

            // If this is today's date, also update the current userBodyweight
            if (date === todayKey) {
                userBodyweight = parseFloat(weight);
                document.getElementById('currentBodyweight').value = userBodyweight;
            }
            
            saveData();
            renderBodyweightChart();
            if (showAlert) alert(`Bodyweight for ${date} logged as ${weight}.`);
        }

        // Renders the bodyweight chart
        function renderBodyweightChart() {
            const ctx = document.getElementById('bodyweightChart');
            if (!ctx) return; // If tab not visible or element not found

            if (bodyweightChartInstance) {
                bodyweightChartInstance.destroy(); // Destroy previous instance to avoid conflicts
            }
            if (bodyweightHistory.length === 0) {
                 ctx.getContext('2d').clearRect(0, 0, ctx.width, ctx.height); // Clear canvas
                 // Optionally display a message like "No bodyweight data logged yet."
                return;
            }

            const labels = bodyweightHistory.map(entry => entry.date);
            const data = bodyweightHistory.map(entry => entry.weight);
            const root = getComputedStyle(document.documentElement);
            const lineColour = root.getPropertyValue('--md-purple-500').trim() || '#673AB7';
            const bgColour   = root.getPropertyValue('--md-purple-100').trim() || '#D1C4E9';

            bodyweightChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Bodyweight (kg/lbs)',
                        data: data,
                        borderColor: 'var(--md-purple-500)',
                        backgroundColor: 'var(--md-purple-100)',
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: false // Adjust as needed, true if BW can't be very low
                        }
                    }
                }
            });
        }
        
        // Updates the attendance summary
        function updateAttendanceSummary() {
            const summaryElement = document.getElementById('attendanceSummary');
            if (!summaryElement) return;

            let loggedThisWeek = 0;
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 (Sun) - 6 (Sat)
            // Adjust to make Monday the start of the week (if Sunday is 0)
            const startOfWeek = new Date(today);
            startOfWeek.setDate(today.getDate() - (dayOfWeek === 0 ? 6 : dayOfWeek - 1)); // Monday
            startOfWeek.setHours(0, 0, 0, 0);

            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6); // Sunday
            endOfWeek.setHours(23, 59, 59, 999);

            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                    const dateStr = key.substring(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`.length);
                    const logDate = new Date(dateStr + "T00:00:00"); // Ensure parsing as local date

                    if (logDate >= startOfWeek && logDate <= endOfWeek) {
                        const logContent = JSON.parse(localStorage.getItem(key));
                        if (Object.keys(logContent).length > 0) { // If any activity logged for that day
                            loggedThisWeek++;
                        }
                    }
                }
            }
            summaryElement.textContent = `Workout days this week: ${loggedThisWeek}`;
        }


        // Renders the e1RM management table
        function renderE1RMTable() {
            const tbody = document.getElementById('e1rmTableBody');
            tbody.innerHTML = ''; 
            CORE_LIFTS_IN_PLAN.forEach(liftName => {
                const row = tbody.insertRow();
                row.insertCell().textContent = liftName;
                
                const currentE1RMCell = row.insertCell();
                const currentE1RM = exercisesE1RM[liftName] || 0;
                currentE1RMCell.textContent = currentE1RM.toFixed(1);
                
                if (e1RMChangeStatus[liftName]) {
                    const indicatorSpan = document.createElement('span');
                    indicatorSpan.classList.add('e1rm-change-indicator');
                    if (e1RMChangeStatus[liftName] === "increased") {
                        indicatorSpan.textContent = " ↑";
                        indicatorSpan.classList.add('increased');
                    } else if (e1RMChangeStatus[liftName] === "decreased") {
                        indicatorSpan.textContent = " ↓";
                        indicatorSpan.classList.add('decreased');
                    }
                    currentE1RMCell.appendChild(indicatorSpan);
                }
                
                const inputCell = row.insertCell();
                const input = document.createElement('input');
                input.type = 'number';
                input.value = currentE1RM.toFixed(1); 
                input.setAttribute('data-lift', liftName);
                inputCell.appendChild(input);
            });
        }
        
        // Saves just the Claude API key
        function saveClaudeApiKey() {
            const apiKeyInput = document.getElementById('claudeApiKey');
            claudeApiKey = apiKeyInput.value.trim();
            localStorage.setItem(`personalizedPlanClaudeApiKey_${APP_VERSION_KEY}`, claudeApiKey);
            
            const statusDiv = document.getElementById('apiKeyStatus');
            statusDiv.textContent = 'API key saved!';
            statusDiv.style.color = 'var(--md-green-500)';
        }

        // Test the Claude API key
        async function testClaudeApiKey() {
            const apiKeyInput = document.getElementById('claudeApiKey');
            const statusDiv = document.getElementById('apiKeyStatus');
            
            const tempKey = apiKeyInput.value.trim();
            if (!tempKey) {
                statusDiv.textContent = 'Please enter an API key first';
                statusDiv.style.color = 'var(--md-red-500)';
                return;
            }

            if (!tempKey.startsWith('sk-ant-')) {
                statusDiv.textContent = 'Invalid API key format. Should start with "sk-ant-"';
                statusDiv.style.color = 'var(--md-red-500)';
                return;
            }

            statusDiv.textContent = 'Testing API key...';
            statusDiv.style.color = 'var(--md-grey-700)';

            // Temporarily set the key for testing
            const originalKey = claudeApiKey;
            claudeApiKey = tempKey;

            try {
                const result = await testApiKey();
                if (result.valid) {
                    statusDiv.textContent = '✓ API key is valid and working!';
                    statusDiv.style.color = 'var(--md-green-500)';
                } else {
                    statusDiv.textContent = `✗ ${result.message}`;
                    statusDiv.style.color = 'var(--md-red-500)';
                }
            } catch (error) {
                statusDiv.textContent = `✗ Test failed: ${error.message}`;
                statusDiv.style.color = 'var(--md-red-500)';
            }

            // Restore original key
            claudeApiKey = originalKey;
        }

        // Saves all e1RMs and current bodyweight from the editable fields in the table
        function saveAllSettingsAndE1RMs() {
            // Save e1RMs
            const inputs = document.querySelectorAll('#e1rmTableBody input[data-lift]');
            inputs.forEach(input => {
                const liftName = input.getAttribute('data-lift');
                const newE1RM = parseFloat(input.value);
                const oldE1RM = exercisesE1RM[liftName] || 0;

                if (!isNaN(newE1RM) && newE1RM >= 0) { 
                    exercisesE1RM[liftName] = newE1RM;
                    if (newE1RM > oldE1RM) {
                        e1RMChangeStatus[liftName] = "increased";
                    } else if (newE1RM < oldE1RM) {
                        e1RMChangeStatus[liftName] = "decreased";
                    } else {
                        delete e1RMChangeStatus[liftName]; 
                    }
                }
            });
            
            // Save current bodyweight and log it for today
            const bwInput = document.getElementById('currentBodyweight');
            const newBw = parseFloat(bwInput.value);
            if (!isNaN(newBw) && newBw > 0) {
                userBodyweight = newBw;
                logBodyweightEntry(todayKey, newBw, false); // Log it for history, no separate alert
            } else if (bwInput.value.trim() !== "") { 
                // only alert if user tried to input something invalid, not if it was blank
                alert("Invalid bodyweight entered. Bodyweight not saved.");
            }

            // Save Claude API key
            const apiKeyInput = document.getElementById('claudeApiKey');
            claudeApiKey = apiKeyInput.value.trim();

            saveData(); 
            renderE1RMTable(); 
            if (currentActiveTab === 'workoutDayTab' && currentSelectedDayKey) {
                 displayWorkoutForDay(currentSelectedDayKey);
            }
            alert('Settings & e1RMs saved!');
        }

        // General function to show a tab and hide others
        function showTab(tabId) {
            currentActiveTab = tabId;
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');

            document.querySelectorAll('#mainNav button').forEach(btn => {
                btn.classList.remove('active'); 
            });

            const activeNavButton = document.querySelector(`#mainNav button[data-tab='${tabId}']:not([data-day-key])`);
            if (activeNavButton) { 
                activeNavButton.classList.add('active');
            } else if (tabId === 'workoutDayTab' && currentSelectedDayKey) { 
                const activeDayButton = document.querySelector(`#mainNav button[data-day-key="${currentSelectedDayKey}"]`);
                if (activeDayButton) activeDayButton.classList.add('active');
            }

            if (tabId === 'analyticsTab') { // If switching to analytics tab, initialize analytics and bodyweight tracking
                initializeAnalytics();
                renderBodyweightChart();
                updateAttendanceSummary();
            }
        }
        
        // Displays the workout for the selected workout type
        function displayWorkoutForDay(workoutKey) {
            currentSelectedDayKey = workoutKey; 
            showTab('workoutDayTab'); 

            const displayArea = document.getElementById('workoutDisplayArea');
            const dayTitleElement = document.getElementById('workoutDayTitle');
            
            if (dayTitleElement) { 
                dayTitleElement.textContent = `${workoutKey}`;
            }
            displayArea.innerHTML = `<h2 id="workoutDayTitle">${workoutKey}</h2>`; 
            
            const workoutItems = USER_WORKOUT_PLAN[workoutKey];
            if (!workoutItems) {
                displayArea.innerHTML += "<p>No workout found for this type.</p>";
                renderDailyLog(); 
                return;
            }

            workoutItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('exercise-item');
                let e1RM = exercisesE1RM[item.group || item.liftName] || 0;
                let targetWeight = 0;
                let isBodyweightExercise = BODYWEIGHT_ASSISTED_EXERCISES.includes(item.liftName);

                let content = `<h3>${item.setLabel || item.name || item.liftName}</h3>`;
                if (item.details) content += `<p class="exercise-details">${item.details}</p>`;

                const isLogged = dailyLog[item.id] && dailyLog[item.id].completed;
                const completedMark = isLogged ? ` <span class="completed-marker">✓ Logged</span>` : '';

                if (item.type === 'strength_single_heavy' || item.type === 'strength_volume') {
                    targetWeight = e1RM > 0 && item.percentage ? (e1RM * item.percentage) : 0; // Keep as number for BW calc
                    let repDisplay = item.repsTarget || item.reps;
                    let targetWeightDisplay = targetWeight > 0 ? targetWeight.toFixed(1) : 'N/A (Set e1RM)';
                    
                    if (isBodyweightExercise && e1RM > 0 && userBodyweight > 0) {
                        const targetAddedWeight = targetWeight - userBodyweight;
                        targetWeightDisplay = `BW + ${targetAddedWeight > 0 ? targetAddedWeight.toFixed(1) : '0'} kg/lbs`;
                         if (targetAddedWeight < 0) targetWeightDisplay = `Bodyweight (assisted if needed)`;
                    } else if (isBodyweightExercise && (e1RM <= 0 || userBodyweight <=0)) {
                        targetWeightDisplay = 'N/A (Set e1RM & BW)';
                    }
                    content += `<p class="exercise-details">${item.sets} set(s) of ${repDisplay} reps @ ~${targetWeightDisplay} (target)</p>`;
                } else if (item.type === 'accessory') {
                    let repDetail = item.reps ? `${item.reps} reps` : `${item.repsRange} reps`;
                    content += `<p class="exercise-details">${item.sets} set(s) of ${repDetail}</p>`;
                     if (isBodyweightExercise) {
                        content += `<p class="exercise-details" style="font-style:italic; font-size:0.85em;">(Log added weight only)</p>`;
                    }
                } else if (item.type === 'hiit' || item.type === 'cardio') {
                     content += `<p class="exercise-details">Duration: ${item.duration || ''}, Intensity: ${item.intensity || ''}</p>`;
                }

                if (item.notes) content += `<p class="exercise-notes">${item.notes}</p>`;
                
                if (item.type === 'strength_single_heavy') {
                    let prefillWtValue;
                    if (isBodyweightExercise) {
                        prefillWtValue = dailyLog[item.id]?.actualAddedWeight !== undefined ? dailyLog[item.id]?.actualAddedWeight : 
                                         (e1RM > 0 && userBodyweight > 0 && targetWeight > 0 ? Math.max(0, targetWeight - userBodyweight).toFixed(1) : "0");
                    } else {
                       prefillWtValue = dailyLog[item.id]?.actualWeight !== undefined ? dailyLog[item.id]?.actualWeight : (targetWeight > 0 ? targetWeight.toFixed(1) : '');
                    }
                    const weightLabel = isBodyweightExercise ? "Added Wt:" : "Actual Wt:";
                    content += `
                        <div class="inline-inputs">
                            <label>${weightLabel}</label><input type="number" id="${item.id}_weight" placeholder="Wt" value="${prefillWtValue}">
                            <label>Reps:</label><input type="number" id="${item.id}_reps" placeholder="Reps" value="${dailyLog[item.id]?.actualReps || ''}">
                            <label>RPE:</label><input type="number" id="${item.id}_rpe" step="0.5" min="6" max="10" placeholder="RPE" value="${dailyLog[item.id]?.actualRPE || ''}">
                        </div>
                        <button class="action-button log-set-button" onclick="logHeavyStrengthSet('${item.id}', '${item.group || item.liftName}')" ${isLogged ? 'disabled' : ''}>Log Set</button>
                    `;
                } else if (item.type === 'strength_volume') {
                     for (let i = 1; i <= item.sets; i++) {
                        const setLogged = dailyLog[item.id] && dailyLog[item.id][`set${i}`] && dailyLog[item.id][`set${i}`].completed;
                        const setCompletedMark = setLogged ? ` <span class="completed-marker">✓</span>` : '';
                        const setData = dailyLog[item.id]?.[`set${i}`];
                        
                        let prefillWeightValue;
                        if (isBodyweightExercise) {
                            prefillWeightValue = setData?.actualAddedWeight !== undefined ? setData.actualAddedWeight :
                                                (e1RM > 0 && userBodyweight > 0 && targetWeight > 0 ? Math.max(0, targetWeight - userBodyweight).toFixed(1) : "0");
                        } else {
                            prefillWeightValue = setData?.actualWeight !== undefined ? setData.actualWeight : (targetWeight > 0 ? targetWeight.toFixed(1) : '');
                        }
                        const weightLabel = isBodyweightExercise ? "Added Wt:" : "Actual Wt:";
                        let targetWeightDisplay = targetWeight > 0 ? targetWeight.toFixed(1) : "N/A";
                        if (isBodyweightExercise && e1RM > 0 && userBodyweight > 0 && targetWeight > 0) {
                             const targetAdded = targetWeight - userBodyweight;
                             targetWeightDisplay = `BW + ${targetAdded > 0 ? targetAdded.toFixed(1) : '0'}`;
                             if (targetAdded < 0) targetWeightDisplay = `Bodyweight`;
                        } else if (isBodyweightExercise) {
                            targetWeightDisplay = 'N/A (Set e1RM & BW)';
                        }


                        content += `
                            <div class="inline-inputs" style="margin-top:5px;">
                                <span>Set ${i} (Target: ${item.reps} reps @ ~${targetWeightDisplay}):</span><br>
                                <label>${weightLabel}</label><input type="number" id="${item.id}_set${i}_weight" placeholder="Wt" value="${prefillWeightValue}">
                                <label>Reps:</label><input type="number" id="${item.id}_set${i}_reps" placeholder="Reps" value="${setData?.actualReps || ''}">
                                <label>RPE:</label><input type="number" id="${item.id}_set${i}_rpe" step="0.5" min="6" max="10" placeholder="RPE" value="${setData?.actualRPE || ''}">
                                <button class="action-button log-set-button" style="padding: 5px 8px; font-size:0.8em;" onclick="logGenericSet('${item.id}', '${item.group || item.liftName}', ${i})" ${setLogged ? 'disabled' : ''}>Log Set ${i}</button> ${setCompletedMark}
                            </div>`;
                    }
                } else if (item.type === 'accessory') {
                    content += `<div>`;
                    for (let i = 1; i <= item.sets; i++) {
                        const setLogged = dailyLog[item.id] && dailyLog[item.id][`set${i}`] && dailyLog[item.id][`set${i}`].completed;
                        const setCompletedMark = setLogged ? ` <span class="completed-marker">✓</span>` : '';
                        const setData = dailyLog[item.id]?.[`set${i}`];
                        let logDisplay = '';
                        if(setData) {
                            const loggedWt = isBodyweightExercise ? `BW + ${setData.actualAddedWeight}` : setData.actualWeight;
                            logDisplay = `(Logged: ${loggedWt}x${setData.actualReps}@${setData.actualRPE}RPE)`;
                        }
                        content += `<button class="action-button" style="margin-right:5px; margin-bottom:5px;" onclick="openAccessoryLogModal('${item.id}', '${item.liftName}', ${i})" ${setLogged ? 'disabled' : ''}>Log Set ${i}</button> ${setCompletedMark} <span style="font-size:0.8em;">${logDisplay}</span> <br>`;
                    }
                    content += `</div>`;
                } else if (item.type === 'mobility' || item.type === 'hiit' || item.type === 'cardio') {
                    content += `<button class="action-button" onclick="logActivityAsCompleted('${item.id}')" ${isLogged ? 'disabled' : ''}>Mark Completed</button>`;
                }

                // ----- user notes UI -----
                content += `
                    <label style="display:block; margin-top:10px;">Notes:</label>
                    <textarea id="${item.id}_userNotes"
                              rows="2"
                              style="width:100%; box-sizing:border-box;"
                              placeholder="Add notes...">${dailyLog[item.id]?.userNotes || ''}</textarea>
                    <button class="action-button"
                            style="margin-top:6px; padding:6px 12px; font-size:0.85em;"
                            onclick="saveExerciseNotes('${item.id}')">Save Notes</button>
                `;

                itemDiv.innerHTML = content + completedMark; 
                displayArea.appendChild(itemDiv);
            });
             renderDailyLog(); 
        }

        function logHeavyStrengthSet(itemId, groupName) {
            try {
                const addedWeightInput = parseFloat(document.getElementById(`${itemId}_weight`).value); // This is either total weight or added weight
                const reps = parseInt(document.getElementById(`${itemId}_reps`).value);
                const rpe = parseFloat(document.getElementById(`${itemId}_rpe`).value);

                // Enhanced input validation
                if (isNaN(addedWeightInput) || addedWeightInput < 0) {
                    showError('Please enter a valid weight (0 or positive number)');
                    return;
                }
                if (isNaN(reps) || reps <= 0 || reps > 50) {
                    showError('Please enter valid reps (1-50)');
                    return;
                }
                if (isNaN(rpe) || rpe < 6 || rpe > 10) {
                    showError('Please enter valid RPE (6-10)');
                    return;
                }
                if (BODYWEIGHT_ASSISTED_EXERCISES.includes(groupName) && addedWeightInput < 0) {
                    showError('Added weight for bodyweight exercises cannot be negative. Use 0 for bodyweight only.');
                    return;
                }
            
            let totalWeightLifted = addedWeightInput;
            let actualLoggedWeight = addedWeightInput; // What gets stored as "actualWeight" in log
            let actualLoggedAddedWeight = null;     // Specifically for BW exercises

            if (BODYWEIGHT_ASSISTED_EXERCISES.includes(groupName)) {
                if (userBodyweight <= 0) {
                    alert("Please set your bodyweight in the 'Settings & e1RMs' tab to accurately log this exercise.");
                    return;
                }
                totalWeightLifted = userBodyweight + addedWeightInput;
                actualLoggedAddedWeight = addedWeightInput; // Store the added part
                actualLoggedWeight = totalWeightLifted; // For e1RM calc, use total
            }


            const e1RMAtSetStart = exercisesE1RM[groupName] || 0; 
            const effectiveReps = getEffectiveReps(reps, rpe);
            const e1RMCalcFromSet = calculateEpleyE1RM(totalWeightLifted, effectiveReps);

            let finalGroupE1RM = e1RMAtSetStart;
            if (e1RMCalcFromSet > 0) {
                finalGroupE1RM = Math.max(e1RMAtSetStart, e1RMCalcFromSet);
                if (finalGroupE1RM > e1RMAtSetStart) {
                    e1RMChangeStatus[groupName] = "increased";
                } else if (finalGroupE1RM < e1RMAtSetStart && e1RMAtSetStart !== 0) { 
                    e1RMChangeStatus[groupName] = "decreased";
                } else {
                     delete e1RMChangeStatus[groupName]; 
                }
                exercisesE1RM[groupName] = finalGroupE1RM;
            } else {
                 delete e1RMChangeStatus[groupName]; 
            }

            dailyLog[itemId] = { 
                completed: true, 
                actualWeight: actualLoggedWeight, // Log total weight if BW, else just weight
                actualAddedWeight: actualLoggedAddedWeight, // Log added weight if applicable
                actualReps: reps, 
                actualRPE: rpe, 
                e1RMAtSetStart: e1RMAtSetStart, 
                e1RMCalcFromSet: e1RMCalcFromSet,
                groupE1RMAfterSet: finalGroupE1RM 
            };
            saveData();
            renderE1RMTable(); 
            displayWorkoutForDay(currentSelectedDayKey); 
            alert(`${groupName} set logged. Group e1RM (total load) is now ${finalGroupE1RM.toFixed(1)}.`);
            
            // Auto-start rest timer for main/activation sets
            startRestTimer(180); // 3 minutes for heavy sets
            
            } catch (error) {
                showError('Failed to log set', error.message);
            }
        }

        function logGenericSet(itemId, groupName, setIndex) {
            const addedWeightInput = parseFloat(document.getElementById(`${itemId}_set${setIndex}_weight`).value);
            const reps = parseInt(document.getElementById(`${itemId}_set${setIndex}_reps`).value);
            const rpe = parseFloat(document.getElementById(`${itemId}_set${setIndex}_rpe`).value);
            
            if (isNaN(addedWeightInput) || isNaN(reps) || isNaN(rpe) || reps < 0) { 
                alert(`Please enter valid (added) weight, reps, and RPE for Set ${setIndex}.`);
                return;
            }
            if (BODYWEIGHT_ASSISTED_EXERCISES.includes(groupName) && addedWeightInput < 0) {
                alert('Added weight for bodyweight exercises cannot be negative. Use 0 for bodyweight only.');
                return;
            }

            let totalWeightLifted = addedWeightInput;
            let actualLoggedWeight = addedWeightInput;
            let actualLoggedAddedWeight = null;

            if (BODYWEIGHT_ASSISTED_EXERCISES.includes(groupName)) {
                 if (userBodyweight <= 0) {
                    alert("Please set your bodyweight in the 'Settings & e1RMs' tab to accurately log this exercise.");
                    return;
                }
                totalWeightLifted = userBodyweight + addedWeightInput;
                actualLoggedAddedWeight = addedWeightInput;
                actualLoggedWeight = totalWeightLifted;
            }


            if (!dailyLog[itemId]) dailyLog[itemId] = { completed: false }; 
            if (!dailyLog[itemId][`set${setIndex}`]) dailyLog[itemId][`set${setIndex}`] = {};
            
            dailyLog[itemId][`set${setIndex}`] = { 
                completed: true, 
                actualWeight: actualLoggedWeight, 
                actualAddedWeight: actualLoggedAddedWeight,
                actualReps: reps, 
                actualRPE: rpe 
            };
            
            const planItem = USER_WORKOUT_PLAN[currentSelectedDayKey].find(it => it.id === itemId);
            let allSetsDone = true;
            if (planItem && planItem.sets) {
                for (let i = 1; i <= planItem.sets; i++) {
                    if (!dailyLog[itemId]?.[`set${i}`]?.completed) {
                        allSetsDone = false;
                        break;
                    }
                }
            }
            if(allSetsDone) dailyLog[itemId].completed = true;

            if (CORE_LIFTS_IN_PLAN.includes(groupName)) {
                const e1RMAtSetStart = exercisesE1RM[groupName] || 0;
                const effectiveReps = getEffectiveReps(reps, rpe);
                const e1RMCalcFromSet = calculateEpleyE1RM(totalWeightLifted, effectiveReps);
                if (e1RMCalcFromSet > 0 && e1RMCalcFromSet > e1RMAtSetStart) { 
                    exercisesE1RM[groupName] = e1RMCalcFromSet; 
                    e1RMChangeStatus[groupName] = "increased";
                    dailyLog[itemId][`set${setIndex}`].newGroupE1RM = e1RMCalcFromSet; 
                } 
            }

            saveData();
            renderE1RMTable();
            displayWorkoutForDay(currentSelectedDayKey);
            alert(`${groupName} Set ${setIndex} logged.`);
            
            // Auto-start rest timer for volume sets (shorter rest)
            startRestTimer(120); // 2 minutes for volume sets
        }
        
        function openAccessoryLogModal(itemId, liftName, setIndex) {
            document.getElementById('modalTitle').textContent = `Log Set ${setIndex} for ${liftName}`;
            document.getElementById('modalExerciseName').value = liftName; 
            document.getElementById('modalSetIndex').value = setIndex;     
            document.getElementById('accessoryLogModal').setAttribute('data-item-id', itemId); 

            const weightLabel = document.getElementById('modalWeightLabel');
            if (BODYWEIGHT_ASSISTED_EXERCISES.includes(liftName)) {
                weightLabel.textContent = "Added Weight:";
            } else {
                weightLabel.textContent = "Weight:";
            }

            const existingLog = dailyLog[itemId]?.[`set${setIndex}`];
            let prefillWeight = "";
            if (existingLog) {
                prefillWeight = BODYWEIGHT_ASSISTED_EXERCISES.includes(liftName) ? 
                                (existingLog.actualAddedWeight !== null ? existingLog.actualAddedWeight : '') : 
                                (existingLog.actualWeight !== null ? existingLog.actualWeight : '');
            }

            document.getElementById('modalWeight').value = prefillWeight;
            document.getElementById('modalReps').value = existingLog?.actualReps || '';
            document.getElementById('modalRPE').value = existingLog?.actualRPE || '';
            
            document.getElementById('accessoryLogModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('accessoryLogModal').style.display = 'none';
        }

        function submitAccessorySetLog() {
            const itemId = document.getElementById('accessoryLogModal').getAttribute('data-item-id');
            const liftName = document.getElementById('modalExerciseName').value;
            const setIndex = parseInt(document.getElementById('modalSetIndex').value);
            
            const addedWeightInput = parseFloat(document.getElementById('modalWeight').value); // Value from modal is added weight or total weight
            const reps = parseInt(document.getElementById('modalReps').value);
            const rpe = parseFloat(document.getElementById('modalRPE').value);

            if (isNaN(addedWeightInput) || isNaN(reps) || isNaN(rpe) || reps < 0) {
                alert('Please enter valid (added) weight, reps, and RPE.');
                return;
            }
            if (BODYWEIGHT_ASSISTED_EXERCISES.includes(liftName) && addedWeightInput < 0) {
                alert('Added weight for bodyweight exercises cannot be negative. Use 0 for bodyweight only.');
                return;
            }

            let totalWeightLifted = addedWeightInput;
            let actualLoggedWeight = addedWeightInput;
            let actualLoggedAddedWeight = null;

            if (BODYWEIGHT_ASSISTED_EXERCISES.includes(liftName)) {
                 if (userBodyweight <= 0) {
                    alert("Please set your bodyweight in the 'Settings & e1RMs' tab to accurately log this exercise.");
                    return;
                }
                totalWeightLifted = userBodyweight + addedWeightInput;
                actualLoggedAddedWeight = addedWeightInput;
                actualLoggedWeight = totalWeightLifted; // Store total for consistency in e1RM calc
            }


            if (!dailyLog[itemId]) dailyLog[itemId] = { completed: false };
            if (!dailyLog[itemId][`set${setIndex}`]) dailyLog[itemId][`set${setIndex}`] = {};

            dailyLog[itemId][`set${setIndex}`] = { 
                completed: true, 
                actualWeight: actualLoggedWeight, // Store total weight for consistency
                actualAddedWeight: actualLoggedAddedWeight, // Store added weight for display/editing
                actualReps: reps, 
                actualRPE: rpe 
            };

            const planItem = USER_WORKOUT_PLAN[currentSelectedDayKey].find(it => it.id === itemId);
            let allSetsDone = true;
            if (planItem && planItem.sets) {
                for (let i = 1; i <= planItem.sets; i++) {
                    if (!dailyLog[itemId]?.[`set${i}`]?.completed) {
                        allSetsDone = false;
                        break;
                    }
                }
            }
             if(allSetsDone) dailyLog[itemId].completed = true;

            if (CORE_LIFTS_IN_PLAN.includes(liftName)) {
                const e1RMAtSetStart = exercisesE1RM[liftName] || 0;
                const effectiveReps = getEffectiveReps(reps, rpe);
                const e1RMCalcFromSet = calculateEpleyE1RM(totalWeightLifted, effectiveReps);
                if (e1RMCalcFromSet > 0 && e1RMCalcFromSet > e1RMAtSetStart) { 
                    exercisesE1RM[liftName] = e1RMCalcFromSet;
                    e1RMChangeStatus[liftName] = "increased";
                    dailyLog[itemId][`set${setIndex}`].newGroupE1RM = e1RMCalcFromSet;
                } 
            }
            
            saveData();
            renderE1RMTable();
            displayWorkoutForDay(currentSelectedDayKey);
            closeModal();
            alert(`${liftName} Set ${setIndex} logged.`);
            
            // Auto-start rest timer for accessory sets
            startRestTimer(90); // 1.5 minutes for accessory sets
        }

        function logActivityAsCompleted(itemId) {
            dailyLog[itemId] = { completed: true, loggedAt: new Date().toLocaleTimeString() };
            saveData();
            displayWorkoutForDay(currentSelectedDayKey); 
            alert(`Activity marked as completed.`);
        }

        // ----------  PER-EXERCISE NOTES ----------
        function saveExerciseNotes(itemId) {
            const input = document.getElementById(`${itemId}_userNotes`);
            if (!input) return;

            // guarantee the node exists in dailyLog
            if (!dailyLog[itemId]) dailyLog[itemId] = { completed: false };

            dailyLog[itemId].userNotes = input.value.trim();
            saveData();
            alert('Notes saved.');
        }
        
        function renderDailyLog() {
            const container = document.getElementById('dailyWorkoutLogContainer');
            container.innerHTML = ''; 
            Object.keys(dailyLog).sort().forEach(itemId => { 
                const logItem = dailyLog[itemId];
                const planItem = Object.values(USER_WORKOUT_PLAN).flat().find(p => p.id === itemId);
                let logText = `<strong>${planItem?.setLabel || planItem?.name || planItem?.liftName || itemId}:</strong> `;

                if (logItem.completed === true) {
                    if (logItem.actualReps !== undefined && logItem.e1RMCalcFromSet !== undefined) { // Heavy single set
                        let weightDisplay = logItem.actualWeight;
                        if (logItem.actualAddedWeight !== null) {
                             weightDisplay = `BW + ${logItem.actualAddedWeight}`;
                        }
                        logText += `${weightDisplay}x${logItem.actualReps}@${logItem.actualRPE}RPE. e1RM from set: ${logItem.e1RMCalcFromSet.toFixed(1)}. Group e1RM now: ${logItem.groupE1RMAfterSet.toFixed(1)}.`;
                    } else if (Object.keys(logItem).some(key => key.startsWith('set'))) { 
                        let setsSummary = [];
                        for (let i = 1; i <= (planItem?.sets || 0); i++) {
                            if (logItem[`set${i}`]?.completed) {
                                let currentSet = logItem[`set${i}`];
                                let weightDisplay = currentSet.actualWeight;
                                if (currentSet.actualAddedWeight !== null) {
                                    weightDisplay = `BW + ${currentSet.actualAddedWeight}`;
                                }
                                let setStr = `Set ${i}: ${weightDisplay}x${currentSet.actualReps}@${currentSet.actualRPE}RPE`;
                                if(currentSet.newGroupE1RM) setStr += ` (new e1RM: ${currentSet.newGroupE1RM.toFixed(1)})`;
                                setsSummary.push(setStr);
                            }
                        }
                        logText += setsSummary.join('; ') || "Sets logged.";
                    } else { 
                        logText += `Completed at ${logItem.loggedAt || 'Logged'}.`;
                    }
                } else {
                     logText += "In progress..."; 
                }
                if (logItem.userNotes) {
                    logText += `<br><em>Notes: ${logItem.userNotes}</em>`;
                }
                const p = document.createElement('p');
                p.style.margin = '3px 0';
                p.innerHTML = logText;
                container.appendChild(p);
            });
        }

        function clearDailyLog() {
            if(confirm("Are you sure you want to clear all logs for today? This only affects today's checkmarks and entries, not your e1RMs.")) {
                dailyLog = {};
                saveData(); 
                 if (currentActiveTab === 'workoutDayTab' && currentSelectedDayKey) displayWorkoutForDay(currentSelectedDayKey); 
                 else renderDailyLog(); 
            }
        }

        // Smart Recommendations Functions
        function updateSliderValues() {
            document.getElementById('energyLevelValue').textContent = document.getElementById('energyLevel').value;
            document.getElementById('stressLevelValue').textContent = document.getElementById('stressLevel').value;
        }

        function getRecentWorkoutHistory() {
            const history = [];
            const now = new Date();
            
            // Look back 14 days for workout history
            for (let i = 0; i < 14; i++) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                
                const logData = localStorage.getItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${dateStr}`);
                if (logData) {
                    const log = JSON.parse(logData);
                    if (Object.keys(log).length > 0) {
                        // Determine which workout type was done
                        let workoutType = 'Unknown';
                        let totalVolume = 0;
                        let avgRPE = 0;
                        let rpeCount = 0;
                        let muscleGroupsWorked = new Set();
                        
                        for (const [type, exercises] of Object.entries(USER_WORKOUT_PLAN)) {
                            const typeExerciseIds = exercises.map(e => e.id);
                            const logExerciseIds = Object.keys(log);
                            
                            if (typeExerciseIds.some(id => logExerciseIds.includes(id))) {
                                workoutType = type;
                                break;
                            }
                        }
                        
                        // Calculate training metrics
                        for (const [exerciseId, exerciseLog] of Object.entries(log)) {
                            if (exerciseLog.completed && exerciseLog.sets) {
                                exerciseLog.sets.forEach(set => {
                                    if (set.weight && set.reps) {
                                        totalVolume += (set.weight || 0) * (set.reps || 0);
                                    }
                                    if (set.rpe && set.rpe > 0) {
                                        avgRPE += set.rpe;
                                        rpeCount++;
                                    }
                                });
                                
                                // Map muscle groups
                                const exercise = findExerciseInPlan(exerciseId);
                                if (exercise) {
                                    const muscleGroups = getMuscleGroupsForExercise(exercise.liftName || exercise.name);
                                    muscleGroups.forEach(mg => muscleGroupsWorked.add(mg));
                                }
                            }
                        }
                        
                        avgRPE = rpeCount > 0 ? avgRPE / rpeCount : 0;
                        
                        history.push({
                            date: dateStr,
                            workoutType: workoutType,
                            exerciseCount: Object.keys(log).length,
                            completedCount: Object.values(log).filter(l => l.completed).length,
                            totalVolume: totalVolume,
                            avgRPE: avgRPE,
                            muscleGroupsWorked: Array.from(muscleGroupsWorked),
                            daysSinceToday: i
                        });
                    }
                }
            }
            
            return history;
        }
        
        // Helper function to find exercise in workout plan
        function findExerciseInPlan(exerciseId) {
            for (const exercises of Object.values(USER_WORKOUT_PLAN)) {
                const exercise = exercises.find(e => e.id === exerciseId);
                if (exercise) return exercise;
            }
            return null;
        }
        
        // Map exercises to muscle groups
        function getMuscleGroupsForExercise(exerciseName) {
            const exerciseLower = exerciseName.toLowerCase();
            const muscleGroups = [];
            
            // Primary muscle group mapping
            if (exerciseLower.includes('squat') || exerciseLower.includes('lunge')) {
                muscleGroups.push('quads', 'glutes');
            } else if (exerciseLower.includes('deadlift') || exerciseLower.includes('rdl')) {
                muscleGroups.push('hamstrings', 'glutes', 'back');
            } else if (exerciseLower.includes('bench') || exerciseLower.includes('press') && !exerciseLower.includes('leg')) {
                muscleGroups.push('chest', 'shoulders', 'triceps');
            } else if (exerciseLower.includes('row') || exerciseLower.includes('pull')) {
                muscleGroups.push('back', 'biceps');
            } else if (exerciseLower.includes('curl')) {
                muscleGroups.push('biceps');
            } else if (exerciseLower.includes('extension') || exerciseLower.includes('pushdown')) {
                muscleGroups.push('triceps');
            } else if (exerciseLower.includes('shoulder') || exerciseLower.includes('lateral') || exerciseLower.includes('overhead')) {
                muscleGroups.push('shoulders');
            } else if (exerciseLower.includes('calf')) {
                muscleGroups.push('calves');
            } else {
                muscleGroups.push('mixed'); // For complex movements
            }
            
            return muscleGroups;
        }
        
        // Analyze training patterns for periodization
        function analyzeTrainingPatterns(history) {
            const muscleGroupFreq = {};
            const weeklyVolume = {};
            const rpeProgression = [];
            
            // Last 7 days analysis
            const lastWeek = history.filter(h => h.daysSinceToday <= 7);
            const weeklyWorkouts = lastWeek.length;
            const avgWeeklyRPE = lastWeek.reduce((sum, h) => sum + h.avgRPE, 0) / Math.max(lastWeek.length, 1);
            
            // Muscle group frequency analysis
            history.forEach(workout => {
                workout.muscleGroupsWorked.forEach(mg => {
                    muscleGroupFreq[mg] = (muscleGroupFreq[mg] || 0) + 1;
                });
            });
            
            // Volume trends
            const volumeTrend = history.slice(0, 7).reduce((sum, h) => sum + h.totalVolume, 0);
            
            // RPE progression (fatigue accumulation)
            for (let i = 0; i < Math.min(7, history.length); i++) {
                rpeProgression.push(history[i].avgRPE);
            }
            
            return {
                muscleGroupFreq,
                weeklyWorkouts,
                avgWeeklyRPE,
                volumeTrend,
                rpeProgression,
                needsDeload: detectDeloadNeed(rpeProgression, avgWeeklyRPE, weeklyWorkouts)
            };
        }
        
        // Deload detection algorithm
        function detectDeloadNeed(rpeProgression, avgRPE, weeklyWorkouts) {
            // Deload indicators:
            // 1. Consistently high RPE (>8.5) for multiple sessions
            // 2. RPE increasing trend over time
            // 3. High frequency with high intensity
            
            const highRPESessions = rpeProgression.filter(rpe => rpe > 8.5).length;
            const rpeIncreasing = rpeProgression.length > 2 && 
                                  rpeProgression[0] > rpeProgression[rpeProgression.length - 1];
            
            return {
                needed: (highRPESessions >= 3) || (avgRPE > 8.5 && weeklyWorkouts > 4) || rpeIncreasing,
                reason: highRPESessions >= 3 ? 'Consistently high RPE indicating fatigue accumulation' :
                       (avgRPE > 8.5 && weeklyWorkouts > 4) ? 'High frequency with high intensity' :
                       rpeIncreasing ? 'RPE trending upward indicating fatigue' : 'None'
            };
        }
        
        // Auto-progression analysis
        function analyzeProgression(exerciseId, history) {
            const exerciseLogs = [];
            
            // Collect recent performance data for specific exercise
            history.forEach(workout => {
                const date = workout.date;
                const logData = localStorage.getItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${date}`);
                if (logData) {
                    const log = JSON.parse(logData);
                    if (log[exerciseId] && log[exerciseId].sets) {
                        log[exerciseId].sets.forEach(set => {
                            if (set.weight && set.reps && set.rpe) {
                                exerciseLogs.push({
                                    date: date,
                                    weight: set.weight,
                                    reps: set.reps,
                                    rpe: set.rpe,
                                    e1rm: set.weight * (1 + (set.reps / 30)) // Epley formula
                                });
                            }
                        });
                    }
                }
            });
            
            if (exerciseLogs.length < 2) return null;
            
            // Sort by date (most recent first)
            exerciseLogs.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            const recent = exerciseLogs.slice(0, 3); // Last 3 performances
            const avgRPE = recent.reduce((sum, log) => sum + log.rpe, 0) / recent.length;
            
            // Progression recommendation based on RPE patterns
            if (avgRPE < 7) {
                return { type: 'increase', amount: 2.5, reason: 'Low RPE indicates room for progression' };
            } else if (avgRPE > 9) {
                return { type: 'decrease', amount: 2.5, reason: 'High RPE suggests need to reduce load' };
            } else if (avgRPE >= 7 && avgRPE <= 8) {
                const isConsistent = recent.every(log => Math.abs(log.rpe - avgRPE) < 1);
                if (isConsistent) {
                    return { type: 'increase', amount: 1.25, reason: 'Consistent performance allows small progression' };
                }
            }
            
            return { type: 'maintain', amount: 0, reason: 'Continue with current load' };
        }

        // Get detailed recent exercise performance for AI context
        function getDetailedRecentPerformance(workoutHistory, maxWorkouts = 3) {
            const detailedHistory = [];
            
            workoutHistory.slice(0, maxWorkouts).forEach(workout => {
                const date = workout.date;
                const logData = localStorage.getItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${date}`);
                if (logData) {
                    const log = JSON.parse(logData);
                    const exerciseDetails = [];
                    
                    Object.entries(log).forEach(([exerciseId, exerciseData]) => {
                        if (exerciseData.sets && exerciseData.sets.length > 0) {
                            const completedSets = exerciseData.sets.filter(set => set.weight && set.reps && set.rpe);
                            if (completedSets.length > 0) {
                                const avgRPE = completedSets.reduce((sum, set) => sum + set.rpe, 0) / completedSets.length;
                                const totalVolume = completedSets.reduce((sum, set) => sum + (set.weight * set.reps), 0);
                                const highestWeight = Math.max(...completedSets.map(set => set.weight));
                                
                                exerciseDetails.push({
                                    exercise: exerciseId,
                                    sets: completedSets.length,
                                    avgRPE: avgRPE.toFixed(1),
                                    totalVolume: totalVolume,
                                    highestWeight: highestWeight,
                                    setDetails: completedSets.map(set => `${set.weight}kg x ${set.reps} @ RPE ${set.reps}`).join(', ')
                                });
                            }
                        }
                    });
                    
                    if (exerciseDetails.length > 0) {
                        detailedHistory.push({
                            date: date,
                            workoutType: workout.workoutType,
                            exercises: exerciseDetails
                        });
                    }
                }
            });
            
            return detailedHistory;
        }

        // Determine recommended next workout based on program structure
        function getRecommendedNextWorkout(workoutHistory) {
            if (workoutHistory.length === 0) {
                return {
                    recommended: "Squat Day",
                    reasoning: "Starting the program - begin with squat day as the foundation movement"
                };
            }

            const lastWorkout = workoutHistory[0].workoutType;
            const last2Workouts = workoutHistory.slice(0, 2).map(w => w.workoutType);
            const last3Workouts = workoutHistory.slice(0, 3).map(w => w.workoutType);
            
            // Program structure: Squat -> Bench -> Deadlift -> Pull -> (Cardio/Mobility/Rest as needed)
            const mainLifts = ["Squat Day", "Bench Day", "Deadlift Day", "Pull Day"];
            
            // Check for proper rotation
            if (lastWorkout === "Squat Day") {
                return {
                    recommended: "Bench Day",
                    reasoning: "Following program sequence: Squat -> Bench -> Deadlift -> Pull"
                };
            }
            
            if (lastWorkout === "Bench Day") {
                return {
                    recommended: "Deadlift Day", 
                    reasoning: "Following program sequence: Squat -> Bench -> Deadlift -> Pull"
                };
            }
            
            if (lastWorkout === "Deadlift Day") {
                return {
                    recommended: "Pull Day",
                    reasoning: "Following program sequence: Squat -> Bench -> Deadlift -> Pull"
                };
            }
            
            if (lastWorkout === "Pull Day") {
                // Check if user has done all main lifts recently
                const recentMainLifts = last3Workouts.filter(w => mainLifts.includes(w));
                if (recentMainLifts.length >= 3) {
                    return {
                        recommended: "Cardio Day or Rest Day",
                        reasoning: "Completed full cycle of main lifts - time for recovery/cardio"
                    };
                } else {
                    return {
                        recommended: "Squat Day",
                        reasoning: "Starting new cycle after Pull Day"
                    };
                }
            }
            
            // If last workout was Cardio/Mobility/Rest, continue with main lifts
            if (["Cardio Day", "Mobility Day", "Rest Day"].includes(lastWorkout)) {
                // Find which main lift to do next based on what's been done recently
                const recentMainLifts = last3Workouts.filter(w => mainLifts.includes(w));
                
                if (!recentMainLifts.includes("Squat Day")) {
                    return { recommended: "Squat Day", reasoning: "Haven't done squats recently" };
                }
                if (!recentMainLifts.includes("Bench Day")) {
                    return { recommended: "Bench Day", reasoning: "Haven't done bench recently" };
                }
                if (!recentMainLifts.includes("Deadlift Day")) {
                    return { recommended: "Deadlift Day", reasoning: "Haven't done deadlifts recently" };
                }
                if (!recentMainLifts.includes("Pull Day")) {
                    return { recommended: "Pull Day", reasoning: "Haven't done pull work recently" };
                }
                
                // If all main lifts done recently, start new cycle
                return {
                    recommended: "Squat Day",
                    reasoning: "Starting new training cycle"
                };
            }
            
            // Default fallback
            return {
                recommended: "Squat Day",
                reasoning: "Default recommendation to maintain program structure"
            };
        }

        // Test API key validity using a CORS proxy
        async function testApiKey() {
            try {
                // Use local proxy server to avoid CORS issues
                const proxyUrl = 'https://redesigned-fishstick-production.up.railway.app/api/anthropic';
                
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': claudeApiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 10,
                        messages: [{
                            role: 'user',
                            content: 'Test'
                        }]
                    })
                });
                
                if (response.ok) {
                    return { valid: true, message: 'API key is valid' };
                } else {
                    const errorData = await response.text();
                    return { valid: false, message: `API key test failed: ${response.status} - ${errorData}` };
                }
            } catch (error) {
                return { 
                    valid: false, 
                    message: `Connection failed: ${error.message}\n\nMake sure the proxy server is running:\n1. Open terminal in this folder\n2. Run: npm install\n3. Run: npm start\n4. Try the API test again` 
                };
            }
        }

        async function getWorkoutRecommendation() {
            if (!claudeApiKey || claudeApiKey.trim() === '') {
                alert('Please set your Claude API key in the Settings & e1RMs tab to use smart recommendations.');
                return;
            }

            // Validate API key format
            if (!claudeApiKey.startsWith('sk-ant-')) {
                alert('Invalid API key format. Claude API keys should start with "sk-ant-"');
                return;
            }

            const btn = document.getElementById('getRecommendationBtn');
            btn.disabled = true;
            btn.textContent = 'Getting recommendation...';

            try {
                // Gather user input - check if user has actually interacted with the form
                const energyLevel = document.getElementById('energyLevel').value;
                const stressLevel = document.getElementById('stressLevel').value;
                const musclesSore = document.getElementById('musclesSore').value;
                const timeAvailable = document.getElementById('timeAvailable').value;
                const specificGoals = document.getElementById('specificGoals').value;
                
                // Check if user has provided minimal input (not just defaults)
                const hasUserInput = musclesSore.trim() || timeAvailable.trim() || specificGoals.trim() ||
                                   energyLevel !== '7' || stressLevel !== '5';
                
                if (!hasUserInput) {
                    alert('Please provide your current state (energy, stress, soreness, time available) to get personalized recommendations.');
                    return;
                }

                // Get workout history and analyze patterns
                const workoutHistory = getRecentWorkoutHistory();
                const trainingAnalysis = analyzeTrainingPatterns(workoutHistory);
                const detailedRecentPerformance = getDetailedRecentPerformance(workoutHistory, 3);
                const nextWorkoutRecommendation = getRecommendedNextWorkout(workoutHistory);
                
                // Check for equipment limitations
                const equipmentLimitations = document.getElementById('equipmentLimitations')?.value || '';
                
                // Generate auto-progression suggestions for key exercises
                const progressionSuggestions = {};
                const keyExercises = ['squat', 'bench', 'deadlift', 'ohp'];
                keyExercises.forEach(exerciseId => {
                    const progression = analyzeProgression(exerciseId, workoutHistory);
                    if (progression) {
                        progressionSuggestions[exerciseId] = progression;
                    }
                });

                // Prepare enhanced context for Claude
                const prompt = `You are an evidence-based fitness AI following research-backed training principles from Rhonda Patrick's "How to Train" guide. Based on the comprehensive analysis below, recommend ONE specific workout and provide detailed modifications.

TRAINING PRINCIPLES TO FOLLOW:
- Consistency beats perfection, adherence is key
- Progressive overload: gradually increase load/volume (2.5-5kg increments)
- Strength protocol: ≥85% 1RM, 1-5 reps, 2-5min rest, RPE 6-8 (3-4 reps shy of failure)
- Hypertrophy protocol: 60-80% 1RM, 6-12 reps, 1-2min rest, can train to RPE 8-9 on isolation
- Frequency: 2-3x per muscle group per week for optimal gains (≥10 sets/muscle/week)
- Recovery: Quality sleep, nutrition, deloading when needed
- Periodization: Vary intensity and volume systematically
- 80/20 cardio rule: 80% Zone 2 (60-70% HRmax), 20% HIIT (80-95% HRmax)

AVAILABLE WORKOUT TYPES:
${Object.keys(USER_WORKOUT_PLAN).map(type => `- ${type}: ${USER_WORKOUT_PLAN[type].map(ex => ex.liftName || ex.name).join(', ')}`).join('\n')}

PROGRAM STRUCTURE GUIDANCE:
Recommended next workout: ${nextWorkoutRecommendation.recommended}
Reasoning: ${nextWorkoutRecommendation.reasoning}

IMPORTANT: Follow the program sequence (Squat -> Bench -> Deadlift -> Pull) for optimal muscle group recovery and progression. Only deviate if user has specific limitations or fatigue concerns.

USER'S CURRENT STATE:
- Energy Level: ${energyLevel}/10
- Stress Level: ${stressLevel}/10
- Muscle soreness/fatigue: ${musclesSore || 'None mentioned'}
- Time available: ${timeAvailable} minutes
- Specific goals: ${specificGoals || 'None mentioned'}
- Equipment limitations: ${equipmentLimitations || 'None mentioned'}
- Current bodyweight: ${userBodyweight}kg
- Current e1RMs: ${Object.entries(exercisesE1RM).map(([lift, e1rm]) => `${lift}: ${e1rm.toFixed(1)}kg`).join(', ')}

TRAINING ANALYSIS (last 14 days):
- Weekly workout frequency: ${trainingAnalysis.weeklyWorkouts}
- Average weekly RPE: ${trainingAnalysis.avgWeeklyRPE.toFixed(1)}
- Weekly volume: ${trainingAnalysis.volumeTrend.toFixed(0)}kg
- Muscle group frequencies: ${Object.entries(trainingAnalysis.muscleGroupFreq).map(([mg, freq]) => `${mg}: ${freq}x`).join(', ')}
- Deload needed: ${trainingAnalysis.needsDeload.needed ? 'YES - ' + trainingAnalysis.needsDeload.reason : 'No'}

AUTO-PROGRESSION ANALYSIS:
${Object.entries(progressionSuggestions).map(([ex, prog]) => `${ex}: ${prog.type} ${prog.amount}kg - ${prog.reason}`).join('\n') || 'No progression data available'}

RECENT WORKOUT HISTORY:
${workoutHistory.length > 0 ? 
    workoutHistory.map(h => `${h.date}: ${h.workoutType} (${h.completedCount}/${h.exerciseCount} completed, Volume: ${h.totalVolume.toFixed(0)}kg, RPE: ${h.avgRPE.toFixed(1)})`).join('\n') : 
    'No recent workouts logged'}

DETAILED RECENT PERFORMANCE (Last 3 Workouts):
${detailedRecentPerformance.length > 0 ? 
    detailedRecentPerformance.map(workout => 
        `${workout.date} - ${workout.workoutType}:\n` + 
        workout.exercises.map(ex => 
            `  • ${ex.exercise}: ${ex.sets} sets, Top weight: ${ex.highestWeight}kg, Avg RPE: ${ex.avgRPE}, Volume: ${ex.totalVolume}kg\n    Sets: ${ex.setDetails}`
        ).join('\n')
    ).join('\n\n') : 
    'No detailed performance data available'}

CONSIDER:
1. Muscle group frequency targets (2-3x per week)
2. Recovery needs and fatigue accumulation
3. Progressive overload patterns
4. Equipment limitations and exercise substitutions
5. Periodization (strength vs hypertrophy phases)
6. Training load management

If deload is needed, recommend deload protocol: 40-60% normal volume, 70-80% intensity.
For equipment limitations, suggest exercise substitutions from available options.

Please respond in this exact format:
RECOMMENDATION: [Workout Type or DELOAD WEEK]
REASONING: [Detailed explanation based on training analysis and scientific principles]
MODIFICATIONS: [Specific changes to sets, reps, intensity, RPE, and any exercise substitutions]
PROGRESSION: [Weight adjustments based on auto-progression analysis]

Keep response evidence-based and practical.`;

                // Use production proxy server to avoid browser CORS restrictions
                const proxyUrl = 'https://redesigned-fishstick-production.up.railway.app/api/anthropic';
                
                const response = await fetch(proxyUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': claudeApiKey,
                        'anthropic-version': '2023-06-01'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 1000,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.text();
                    console.error('API Error Response:', errorData);
                    throw new Error(`API request failed: ${response.status} - ${errorData}`);
                }

                const data = await response.json();
                
                // Validate response structure
                if (!data.content || !data.content[0] || !data.content[0].text) {
                    console.error('Invalid API response structure:', data);
                    throw new Error('Invalid response structure from API');
                }
                
                const recommendation = data.content[0].text;

                // Parse recommendation
                const lines = recommendation.split('\n');
                const recommendationLine = lines.find(l => l.startsWith('RECOMMENDATION:'));
                const reasoningLine = lines.find(l => l.startsWith('REASONING:'));
                const modificationsLine = lines.find(l => l.startsWith('MODIFICATIONS:'));
                const progressionLine = lines.find(l => l.startsWith('PROGRESSION:'));

                const workoutType = recommendationLine ? recommendationLine.replace('RECOMMENDATION:', '').trim() : 'Squat Day';
                const reasoning = reasoningLine ? reasoningLine.replace('REASONING:', '').trim() : 'AI recommendation based on your current state.';
                const modifications = modificationsLine ? modificationsLine.replace('MODIFICATIONS:', '').trim() : 'Follow the standard workout plan.';
                const progression = progressionLine ? progressionLine.replace('PROGRESSION:', '').trim() : 'No specific progression adjustments needed.';

                currentRecommendation = {
                    workoutType: workoutType,
                    reasoning: reasoning,
                    modifications: modifications,
                    progression: progression
                };

                // Check if this is a deload recommendation
                const isDeload = workoutType.toUpperCase().includes('DELOAD');
                const headerColor = isDeload ? 'var(--md-red-700)' : 'var(--md-purple-700)';
                const bgColor = isDeload ? '#ffebee' : 'var(--md-purple-100)';

                // Display recommendation
                document.getElementById('recommendationContent').innerHTML = `
                    <div style="background-color: ${bgColor}; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid ${headerColor};">
                        <h4 style="margin-top: 0; color: ${headerColor};">
                            ${isDeload ? '🔄 Deload Recommendation' : '💪 Recommended Workout'}: ${workoutType}
                        </h4>
                        <p><strong>📊 Analysis & Reasoning:</strong> ${reasoning}</p>
                        <p><strong>⚙️ Workout Modifications:</strong> ${modifications}</p>
                        <p><strong>📈 Progression Adjustments:</strong> ${progression}</p>
                        <p style="font-size: 0.85em; color: var(--md-grey-700); margin-bottom: 0;"><em>🤖 Generated by Claude AI with evidence-based training principles</em></p>
                    </div>
                `;

                document.getElementById('recommendationResult').style.display = 'block';

            } catch (error) {
                console.error('Error getting recommendation:', error);
                
                // More detailed error message
                let errorMessage = 'Failed to get workout recommendation.\n\n';
                
                if (error.message.includes('401')) {
                    errorMessage += 'Authentication failed - please check your API key.';
                } else if (error.message.includes('429')) {
                    errorMessage += 'Rate limit exceeded - please try again later.';
                } else if (error.message.includes('400')) {
                    errorMessage += 'Bad request - there may be an issue with the request format.';
                } else if (error.message.includes('network') || error.message.includes('fetch') || error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    errorMessage += 'Connection to proxy server failed.\n\n';
                    errorMessage += 'Setup steps:\n';
                    errorMessage += '1. Open terminal in this folder\n';
                    errorMessage += '2. Run: npm install\n';
                    errorMessage += '3. Run: npm start\n';
                    errorMessage += '4. Refresh this page and try again\n\n';
                    errorMessage += 'Or use the simple built-in recommendation system instead?';
                    
                    if (confirm(errorMessage)) {
                        generateSimpleRecommendation();
                        return;
                    }
                } else {
                    errorMessage += `Error details: ${error.message}`;
                }
                
                errorMessage += '\n\nPlease check the browser console for more details.';
                
                alert(errorMessage);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Get Smart Recommendation';
            }
        }

        function acceptRecommendation() {
            if (currentRecommendation && currentRecommendation.workoutType) {
                displayWorkoutForDay(currentRecommendation.workoutType);
                alert(`Starting ${currentRecommendation.workoutType}! Remember: ${currentRecommendation.modifications}`);
            }
        }

        // Enhanced built-in recommendation system (fallback when Claude API fails)
        function generateSimpleRecommendation() {
            const energyLevel = parseInt(document.getElementById('energyLevel').value);
            const stressLevel = parseInt(document.getElementById('stressLevel').value);
            const musclesSore = document.getElementById('musclesSore').value.toLowerCase();
            const timeAvailable = parseInt(document.getElementById('timeAvailable').value);
            const equipmentLimitations = document.getElementById('equipmentLimitations')?.value?.toLowerCase() || '';
            
            // Get recent workout history and analyze patterns
            const workoutHistory = getRecentWorkoutHistory();
            const trainingAnalysis = analyzeTrainingPatterns(workoutHistory);
            const nextWorkoutRecommendation = getRecommendedNextWorkout(workoutHistory);
            const recentWorkouts = workoutHistory.slice(0, 3).map(h => h.workoutType);
            
            // Check for deload need first
            if (trainingAnalysis.needsDeload.needed) {
                currentRecommendation = {
                    workoutType: 'DELOAD WEEK',
                    reasoning: `Deload recommended: ${trainingAnalysis.needsDeload.reason}. Research shows deload weeks (40-60% normal volume, 70-80% intensity) enhance long-term progress.`,
                    modifications: 'Reduce volume by 40-60%. Use 70-80% of normal weights. Focus on movement quality and recovery. Consider extra mobility work.',
                    progression: 'Return to full intensity next week with potential to exceed previous performance.'
                };
                
                document.getElementById('recommendationContent').innerHTML = `
                    <div style="background-color: #ffebee; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid var(--md-red-700);">
                        <h4 style="margin-top: 0; color: var(--md-red-700);">
                            🔄 Deload Recommendation: ${currentRecommendation.workoutType}
                        </h4>
                        <p><strong>📊 Analysis & Reasoning:</strong> ${currentRecommendation.reasoning}</p>
                        <p><strong>⚙️ Workout Modifications:</strong> ${currentRecommendation.modifications}</p>
                        <p><strong>📈 Progression Adjustments:</strong> ${currentRecommendation.progression}</p>
                        <p style="font-size: 0.85em; color: var(--md-grey-700); margin-bottom: 0;"><em>Generated by built-in recommendation system</em></p>
                    </div>
                `;
                
                document.getElementById('recommendationResult').style.display = 'block';
                return;
            }
            
            let workoutType;
            let reasoning;
            let modifications = '';
            let progression = 'No specific progression adjustments needed.';
            
            // Equipment limitations check
            const hasEquipmentLimitations = equipmentLimitations.length > 0;
            
            // Enhanced logic-based recommendations with muscle group frequency consideration
            if (energyLevel <= 4 || stressLevel >= 8) {
                if (timeAvailable < 45) {
                    workoutType = 'Mobility Day';
                    reasoning = 'Low energy/high stress suggests recovery focus. Research shows light movement aids recovery without adding training stress.';
                } else {
                    workoutType = 'Cardio Day';
                    reasoning = 'Low energy/high stress. Zone 2 cardio (60-70% HRmax) is excellent for stress relief and recovery without overtaxing the system.';
                }
            } else if (musclesSore.includes('leg') || musclesSore.includes('squat')) {
                if (!recentWorkouts.includes('Pull Day')) {
                    workoutType = 'Pull Day';
                    reasoning = 'Legs are sore, so focusing on upper body pulling movements. Pull work is often undertrained relative to push movements.';
                } else {
                    workoutType = 'Bench Day';
                    reasoning = 'Legs are sore, and you haven\'t done bench recently. Upper body push focus allows leg recovery.';
                }
            } else if (musclesSore.includes('upper') || musclesSore.includes('shoulder') || musclesSore.includes('chest')) {
                workoutType = 'Squat Day';
                reasoning = 'Upper body is sore, so focusing on lower body strength. Squats are a foundational movement for strength development.';
            } else if (timeAvailable < 45) {
                // Quick workout options - prioritize frequency over volume
                if (!recentWorkouts.includes('Pull Day')) {
                    workoutType = 'Pull Day';
                    reasoning = 'Limited time, and pull work is efficient and often needed. Focus on compound movements for time efficiency.';
                } else {
                    workoutType = 'Mobility Day';
                    reasoning = 'Limited time suggests a quick mobility session. Maintaining range of motion is crucial for long-term training success.';
                }
            } else {
                // Normal energy - consider muscle group frequency (aim for 2-3x per week)
                const muscleGroupNeeds = trainingAnalysis.muscleGroupFreq;
                const workoutOptions = ['Squat Day', 'Bench Day', 'Deadlift Day', 'Pull Day'];
                
                // Prioritize workouts that train undertrained muscle groups
                let selectedWorkout = null;
                if ((muscleGroupNeeds['quads'] || 0) < 2 && !recentWorkouts.includes('Squat Day')) {
                    selectedWorkout = 'Squat Day';
                } else if ((muscleGroupNeeds['back'] || 0) < 2 && !recentWorkouts.includes('Pull Day')) {
                    selectedWorkout = 'Pull Day';
                } else if ((muscleGroupNeeds['chest'] || 0) < 2 && !recentWorkouts.includes('Bench Day')) {
                    selectedWorkout = 'Bench Day';
                } else if ((muscleGroupNeeds['hamstrings'] || 0) < 2 && !recentWorkouts.includes('Deadlift Day')) {
                    selectedWorkout = 'Deadlift Day';
                }
                
                if (selectedWorkout) {
                    workoutType = selectedWorkout;
                    reasoning = `Good energy levels. ${workoutType} targets muscle groups that need more frequency based on your recent training.`;
                } else {
                    const undoneworkouts = workoutOptions.filter(w => !recentWorkouts.includes(w));
                    if (undoneworkouts.length > 0) {
                        workoutType = undoneworkouts[0];
                        reasoning = `Good energy levels and you haven't done ${workoutType} recently. Variety in training stimuli promotes adaptation.`;
                    } else {
                        workoutType = 'Squat Day';
                        reasoning = 'Good energy levels. Squat day is always a solid choice - lower body strength is fundamental to overall performance.';
                    }
                }
            }
            
            // Evidence-based modifications following research principles
            if (energyLevel <= 6) {
                modifications = 'Reduce intensity to 70-80% 1RM. Stay 4-5 reps from failure on strength moves (RPE 6-7). Prioritize movement quality and neural recovery.';
            } else if (energyLevel >= 8 && stressLevel <= 4) {
                modifications = 'High energy state! Work at 85-90% 1RM for strength moves (RPE 8). Can train closer to failure (RPE 8-9) on isolation exercises only.';
            } else {
                modifications = 'Work at planned intensities. Stay 3-4 reps from failure on compound movements per research guidelines.';
            }
            
            // Time-based modifications
            if (timeAvailable < 60) {
                modifications += ' Use 1-2min rest for accessories, 2-3min for compounds. Focus on main lifts only. Consider antagonist supersets.';
            } else if (timeAvailable >= 90) {
                modifications += ' Take full 2-5min rest between strength sets. Add comprehensive warm-up, cool-down, and mobility work.';
            }
            
            // Equipment substitutions
            if (hasEquipmentLimitations) {
                modifications += ` EQUIPMENT SUBSTITUTIONS: ${getEquipmentSubstitutions(workoutType, equipmentLimitations)}`;
            }
            
            // Recovery considerations
            const daysSinceLastWorkout = workoutHistory.length > 0 ? 
                (new Date() - new Date(workoutHistory[0].date)) / (1000 * 60 * 60 * 24) : 7;
            
            if (daysSinceLastWorkout > 3) {
                modifications += ' Start conservatively after rest period - reduce loads by 10-15% for first session back.';
            }
            
            // Auto-progression suggestions
            const keyExercises = ['squat', 'bench', 'deadlift', 'ohp'];
            const progressionSuggestions = [];
            keyExercises.forEach(exerciseId => {
                const progressionAnalysis = analyzeProgression(exerciseId, workoutHistory);
                if (progressionAnalysis && progressionAnalysis.type !== 'maintain') {
                    progressionSuggestions.push(`${exerciseId}: ${progressionAnalysis.type} ${progressionAnalysis.amount}kg (${progressionAnalysis.reason})`);
                }
            });
            
            if (progressionSuggestions.length > 0) {
                progression = progressionSuggestions.join('; ');
            }
            
            // Weekly volume considerations
            if (trainingAnalysis.weeklyWorkouts < 3) {
                modifications += ' Consider adding more sessions this week to meet 3x/week minimum for optimal strength gains.';
            } else if (trainingAnalysis.weeklyWorkouts > 5) {
                modifications += ' High weekly frequency - ensure adequate recovery between sessions.';
            }
            
            currentRecommendation = {
                workoutType: workoutType,
                reasoning: reasoning,
                modifications: modifications,
                progression: progression
            };
            
            // Display recommendation
            document.getElementById('recommendationContent').innerHTML = `
                <div style="background-color: var(--md-purple-100); padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid var(--md-purple-700);">
                    <h4 style="margin-top: 0; color: var(--md-purple-700);">
                        💪 Enhanced Recommendation: ${workoutType}
                    </h4>
                    <p><strong>📊 Analysis & Reasoning:</strong> ${reasoning}</p>
                    <p><strong>⚙️ Workout Modifications:</strong> ${modifications}</p>
                    <p><strong>📈 Progression Adjustments:</strong> ${progression}</p>
                    <p style="font-size: 0.85em; color: var(--md-grey-700); margin-bottom: 0;"><em>🧠 Generated by enhanced built-in recommendation system</em></p>
                </div>
            `;
            
            document.getElementById('recommendationResult').style.display = 'block';
        }
        
        // Equipment substitution suggestions
        function getEquipmentSubstitutions(workoutType, limitations) {
            const substitutions = [];
            
            if (limitations.includes('no barbell') || limitations.includes('no bar')) {
                if (workoutType.includes('Squat')) {
                    substitutions.push('Replace barbell squats with goblet squats or dumbbell squats');
                }
                if (workoutType.includes('Bench')) {
                    substitutions.push('Replace barbell bench with dumbbell bench press or push-ups');
                }
                if (workoutType.includes('Deadlift')) {
                    substitutions.push('Replace barbell deadlifts with dumbbell deadlifts or single-leg RDLs');
                }
            }
            
            if (limitations.includes('no squat rack') || limitations.includes('no rack')) {
                substitutions.push('Use front-loaded variations, goblet squats, or split squats');
            }
            
            if (limitations.includes('dumbbells only') || limitations.includes('home gym')) {
                substitutions.push('Focus on dumbbell variations, single-limb work, and bodyweight movements');
            }
            
            if (limitations.includes('no weights') || limitations.includes('bodyweight')) {
                substitutions.push('Use bodyweight progressions: push-up variations, single-leg squats, pike push-ups');
            }
            
            return substitutions.length > 0 ? substitutions.join('; ') : 'No substitutions needed';
        }

        // Data Export/Import Functions
        function exportData() {
            try {
                const exportData = {
                    version: APP_VERSION_KEY,
                    exportDate: new Date().toISOString(),
                    exercisesE1RM: exercisesE1RM,
                    e1RMChangeStatus: e1RMChangeStatus,
                    userBodyweight: userBodyweight,
                    bodyweightHistory: bodyweightHistory,
                    claudeApiKey: claudeApiKey,
                    dailyLogs: {}
                };

                // Export all daily logs
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                        const date = key.substring(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`.length);
                        exportData.dailyLogs[date] = JSON.parse(localStorage.getItem(key));
                    }
                }

                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `fitness-tracker-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = `Data exported successfully at ${new Date().toLocaleTimeString()}`;
                statusDiv.style.color = 'var(--md-green-500)';
                
            } catch (error) {
                console.error('Export error:', error);
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = 'Export failed. Check console for details.';
                statusDiv.style.color = 'var(--md-red-500)';
            }
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate import data structure
                    if (!importedData.version || !importedData.exportDate) {
                        throw new Error('Invalid backup file format');
                    }

                    const confirmMessage = `Import data from ${new Date(importedData.exportDate).toLocaleDateString()}?\n\nThis will overwrite your current data. Make sure you've exported your current data first!`;
                    
                    if (confirm(confirmMessage)) {
                        // Import core data
                        if (importedData.exercisesE1RM) {
                            exercisesE1RM = importedData.exercisesE1RM;
                        }
                        if (importedData.e1RMChangeStatus) {
                            e1RMChangeStatus = importedData.e1RMChangeStatus;
                        }
                        if (importedData.userBodyweight) {
                            userBodyweight = importedData.userBodyweight;
                            document.getElementById('currentBodyweight').value = userBodyweight;
                        }
                        if (importedData.bodyweightHistory) {
                            bodyweightHistory = importedData.bodyweightHistory;
                        }
                        if (importedData.claudeApiKey) {
                            claudeApiKey = importedData.claudeApiKey;
                            document.getElementById('claudeApiKey').value = claudeApiKey;
                        }

                        // Import daily logs
                        if (importedData.dailyLogs) {
                            // Clear existing daily logs first
                            const keysToRemove = [];
                            for (let i = 0; i < localStorage.length; i++) {
                                const key = localStorage.key(i);
                                if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                                    keysToRemove.push(key);
                                }
                            }
                            keysToRemove.forEach(key => localStorage.removeItem(key));

                            // Import new daily logs
                            Object.entries(importedData.dailyLogs).forEach(([date, logData]) => {
                                localStorage.setItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${date}`, JSON.stringify(logData));
                            });
                        }

                        // Update today's daily log if it exists in import
                        if (importedData.dailyLogs && importedData.dailyLogs[todayKey]) {
                            dailyLog = importedData.dailyLogs[todayKey];
                        }

                        // Save all data and refresh UI
                        saveData();
                        renderE1RMTable();
                        renderBodyweightChart();
                        updateAttendanceSummary();
                        if (currentActiveTab === 'workoutDayTab' && currentSelectedDayKey) {
                            displayWorkoutForDay(currentSelectedDayKey);
                        } else {
                            renderDailyLog();
                        }

                        const statusDiv = document.getElementById('dataManagementStatus');
                        statusDiv.textContent = `Data imported successfully from ${new Date(importedData.exportDate).toLocaleDateString()}`;
                        statusDiv.style.color = 'var(--md-green-500)';
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    const statusDiv = document.getElementById('dataManagementStatus');
                    statusDiv.textContent = 'Import failed. Please check the file format.';
                    statusDiv.style.color = 'var(--md-red-500)';
                    alert('Import failed. Please make sure you selected a valid backup file.');
                }
                
                // Reset file input
                event.target.value = '';
            };
            
            reader.readAsText(file);
        }

        // Enhanced Data Management Functions

        // CSV Export Function
        function exportDataCSV() {
            try {
                let csvContent = "";
                
                // Export e1RM data
                csvContent += "Exercise 1RM Data\n";
                csvContent += "Exercise,Current e1RM (kg),Date Updated\n";
                Object.entries(exercisesE1RM).forEach(([exercise, value]) => {
                    csvContent += `"${exercise}","${value}","${new Date().toISOString().split('T')[0]}"\n`;
                });
                
                csvContent += "\nBodyweight History\n";
                csvContent += "Date,Weight (kg)\n";
                bodyweightHistory.forEach(entry => {
                    csvContent += `"${entry.date}","${entry.weight}"\n`;
                });
                
                // Export daily logs
                csvContent += "\nWorkout Logs\n";
                csvContent += "Date,Exercise,Set,Weight,Reps,RPE,e1RM\n";
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                        const date = key.substring(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`.length);
                        const logData = JSON.parse(localStorage.getItem(key));
                        
                        Object.entries(logData).forEach(([exerciseName, sets]) => {
                            if (Array.isArray(sets)) {
                                sets.forEach((set, index) => {
                                    if (set.weight && set.reps) {
                                        const e1rm = set.weight * (1 + (set.reps / 30));
                                        csvContent += `"${date}","${exerciseName}","${index + 1}","${set.weight}","${set.reps}","${set.rpe || ''}","${e1rm.toFixed(1)}"\n`;
                                    }
                                });
                            }
                        });
                    }
                }
                
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `fitness-tracker-export-${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = `CSV data exported successfully at ${new Date().toLocaleTimeString()}`;
                statusDiv.style.color = 'var(--md-green-500)';
                
            } catch (error) {
                console.error('CSV Export error:', error);
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = 'CSV export failed. Check console for details.';
                statusDiv.style.color = 'var(--md-red-500)';
            }
        }

        // Selective Export Modal Functions
        function showSelectiveExportModal() {
            const modal = document.getElementById('selectiveExportModal');
            modal.style.display = 'block';
            
            // Set default date range (last 30 days)
            const today = new Date();
            const thirtyDaysAgo = new Date(today.getTime() - (30 * 24 * 60 * 60 * 1000));
            document.getElementById('exportStartDate').value = thirtyDaysAgo.toISOString().split('T')[0];
            document.getElementById('exportEndDate').value = today.toISOString().split('T')[0];
            
            // Populate exercise checkboxes
            populateExerciseCheckboxes();
        }

        function closeSelectiveExportModal() {
            document.getElementById('selectiveExportModal').style.display = 'none';
        }

        function populateExerciseCheckboxes() {
            const container = document.getElementById('exerciseCheckboxes');
            container.innerHTML = '';
            
            Object.keys(exercisesE1RM).forEach(exercise => {
                const label = document.createElement('label');
                label.style.display = 'block';
                label.style.marginBottom = '5px';
                label.innerHTML = `<input type="checkbox" value="${exercise}" checked> ${exercise}`;
                container.appendChild(label);
            });
        }

        function selectAllExercises() {
            const checkboxes = document.querySelectorAll('#exerciseCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
        }

        function deselectAllExercises() {
            const checkboxes = document.querySelectorAll('#exerciseCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
        }

        function executeSelectiveExport() {
            try {
                const format = document.querySelector('input[name="exportFormat"]:checked').value;
                const includeE1RMs = document.getElementById('exportE1RMs').checked;
                const includeBodyweight = document.getElementById('exportBodyweight').checked;
                const includeWorkouts = document.getElementById('exportWorkouts').checked;
                const includeSettings = document.getElementById('exportSettings').checked;
                const startDate = document.getElementById('exportStartDate').value;
                const endDate = document.getElementById('exportEndDate').value;
                
                // Get selected exercises
                const selectedExercises = Array.from(document.querySelectorAll('#exerciseCheckboxes input[type="checkbox"]:checked'))
                    .map(cb => cb.value);

                if (format === 'json') {
                    exportSelectiveJSON(includeE1RMs, includeBodyweight, includeWorkouts, includeSettings, startDate, endDate, selectedExercises);
                } else {
                    exportSelectiveCSV(includeE1RMs, includeBodyweight, includeWorkouts, includeSettings, startDate, endDate, selectedExercises);
                }
                
                closeSelectiveExportModal();
                
            } catch (error) {
                console.error('Selective export error:', error);
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = 'Selective export failed. Check console for details.';
                statusDiv.style.color = 'var(--md-red-500)';
            }
        }

        function exportSelectiveJSON(includeE1RMs, includeBodyweight, includeWorkouts, includeSettings, startDate, endDate, selectedExercises) {
            const exportData = {
                version: APP_VERSION_KEY,
                exportDate: new Date().toISOString(),
                exportType: 'selective',
                dateRange: { start: startDate, end: endDate }
            };

            if (includeE1RMs) {
                exportData.exercisesE1RM = {};
                selectedExercises.forEach(exercise => {
                    if (exercisesE1RM[exercise] !== undefined) {
                        exportData.exercisesE1RM[exercise] = exercisesE1RM[exercise];
                    }
                });
                exportData.e1RMChangeStatus = {};
                selectedExercises.forEach(exercise => {
                    if (e1RMChangeStatus[exercise] !== undefined) {
                        exportData.e1RMChangeStatus[exercise] = e1RMChangeStatus[exercise];
                    }
                });
            }

            if (includeBodyweight) {
                exportData.userBodyweight = userBodyweight;
                exportData.bodyweightHistory = bodyweightHistory.filter(entry => {
                    return (!startDate || entry.date >= startDate) && (!endDate || entry.date <= endDate);
                });
            }

            if (includeSettings) {
                exportData.claudeApiKey = claudeApiKey;
            }

            if (includeWorkouts) {
                exportData.dailyLogs = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                        const date = key.substring(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`.length);
                        if ((!startDate || date >= startDate) && (!endDate || date <= endDate)) {
                            const logData = JSON.parse(localStorage.getItem(key));
                            // Filter by selected exercises
                            const filteredLogData = {};
                            selectedExercises.forEach(exercise => {
                                if (logData[exercise]) {
                                    filteredLogData[exercise] = logData[exercise];
                                }
                            });
                            if (Object.keys(filteredLogData).length > 0) {
                                exportData.dailyLogs[date] = filteredLogData;
                            }
                        }
                    }
                }
            }

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `fitness-tracker-selective-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            const statusDiv = document.getElementById('dataManagementStatus');
            statusDiv.textContent = `Selective JSON export completed at ${new Date().toLocaleTimeString()}`;
            statusDiv.style.color = 'var(--md-green-500)';
        }

        function exportSelectiveCSV(includeE1RMs, includeBodyweight, includeWorkouts, includeSettings, startDate, endDate, selectedExercises) {
            let csvContent = `Selective Export - ${new Date().toISOString()}\n`;
            csvContent += `Date Range: ${startDate || 'All'} to ${endDate || 'All'}\n`;
            csvContent += `Selected Exercises: ${selectedExercises.join(', ')}\n\n`;
            
            if (includeE1RMs) {
                csvContent += "Exercise 1RM Data\n";
                csvContent += "Exercise,Current e1RM (kg),Change Status\n";
                selectedExercises.forEach(exercise => {
                    if (exercisesE1RM[exercise] !== undefined) {
                        csvContent += `"${exercise}","${exercisesE1RM[exercise]}","${e1RMChangeStatus[exercise] || 'No change'}"\n`;
                    }
                });
                csvContent += "\n";
            }
            
            if (includeBodyweight) {
                csvContent += "Bodyweight History\n";
                csvContent += "Date,Weight (kg)\n";
                bodyweightHistory.filter(entry => {
                    return (!startDate || entry.date >= startDate) && (!endDate || entry.date <= endDate);
                }).forEach(entry => {
                    csvContent += `"${entry.date}","${entry.weight}"\n`;
                });
                csvContent += "\n";
            }
            
            if (includeWorkouts) {
                csvContent += "Workout Logs\n";
                csvContent += "Date,Exercise,Set,Weight,Reps,RPE,e1RM\n";
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                        const date = key.substring(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`.length);
                        if ((!startDate || date >= startDate) && (!endDate || date <= endDate)) {
                            const logData = JSON.parse(localStorage.getItem(key));
                            
                            selectedExercises.forEach(exerciseName => {
                                if (logData[exerciseName] && Array.isArray(logData[exerciseName])) {
                                    logData[exerciseName].forEach((set, index) => {
                                        if (set.weight && set.reps) {
                                            const e1rm = set.weight * (1 + (set.reps / 30));
                                            csvContent += `"${date}","${exerciseName}","${index + 1}","${set.weight}","${set.reps}","${set.rpe || ''}","${e1rm.toFixed(1)}"\n`;
                                        }
                                    });
                                }
                            });
                        }
                    }
                }
            }
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `fitness-tracker-selective-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            const statusDiv = document.getElementById('dataManagementStatus');
            statusDiv.textContent = `Selective CSV export completed at ${new Date().toLocaleTimeString()}`;
            statusDiv.style.color = 'var(--md-green-500)';
        }

        // Data Integrity and Validation Functions
        function validateDataIntegrity() {
            try {
                const issues = [];
                
                // Check e1RM data integrity
                Object.entries(exercisesE1RM).forEach(([exercise, value]) => {
                    if (typeof value !== 'number' || value <= 0 || value > 1000) {
                        issues.push(`Invalid e1RM value for ${exercise}: ${value}`);
                    }
                });
                
                // Check bodyweight data
                if (typeof userBodyweight !== 'number' || userBodyweight <= 0 || userBodyweight > 1000) {
                    issues.push(`Invalid current bodyweight: ${userBodyweight}`);
                }
                
                bodyweightHistory.forEach((entry, index) => {
                    if (!entry.date || !entry.weight || typeof entry.weight !== 'number') {
                        issues.push(`Invalid bodyweight history entry at index ${index}`);
                    }
                });
                
                // Check daily logs structure
                let logCount = 0;
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                        logCount++;
                        try {
                            const logData = JSON.parse(localStorage.getItem(key));
                            if (typeof logData !== 'object') {
                                issues.push(`Invalid log data structure for ${key}`);
                            }
                        } catch (e) {
                            issues.push(`Corrupted log data for ${key}`);
                        }
                    }
                }
                
                const statusDiv = document.getElementById('dataManagementStatus');
                if (issues.length === 0) {
                    statusDiv.textContent = `Data validation passed! Found ${logCount} workout logs, ${Object.keys(exercisesE1RM).length} exercises, ${bodyweightHistory.length} bodyweight entries.`;
                    statusDiv.style.color = 'var(--md-green-500)';
                } else {
                    statusDiv.textContent = `Data validation found ${issues.length} issues. Check console for details.`;
                    statusDiv.style.color = 'var(--md-orange-500)';
                    console.warn('Data integrity issues:', issues);
                }
                
            } catch (error) {
                console.error('Data validation error:', error);
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = 'Data validation failed. Check console for details.';
                statusDiv.style.color = 'var(--md-red-500)';
            }
        }

        // Auto Backup Functions
        function createAutoBackup() {
            try {
                const backupKey = `personalizedPlanAutoBackup_${APP_VERSION_KEY}_${new Date().toISOString().split('T')[0]}`;
                const backupData = {
                    version: APP_VERSION_KEY,
                    backupDate: new Date().toISOString(),
                    backupType: 'automatic',
                    exercisesE1RM: exercisesE1RM,
                    e1RMChangeStatus: e1RMChangeStatus,
                    userBodyweight: userBodyweight,
                    bodyweightHistory: bodyweightHistory,
                    claudeApiKey: claudeApiKey,
                    dailyLogs: {}
                };

                // Include all daily logs
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`)) {
                        const date = key.substring(`personalizedPlanDailyLog_${APP_VERSION_KEY}_`.length);
                        backupData.dailyLogs[date] = JSON.parse(localStorage.getItem(key));
                    }
                }

                localStorage.setItem(backupKey, JSON.stringify(backupData));
                
                // Clean old auto backups (keep only 5 most recent)
                cleanOldAutoBackups();
                
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = `Auto backup created successfully at ${new Date().toLocaleTimeString()}`;
                statusDiv.style.color = 'var(--md-green-500)';
                
            } catch (error) {
                console.error('Auto backup error:', error);
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = 'Auto backup failed. Storage might be full.';
                statusDiv.style.color = 'var(--md-red-500)';
            }
        }

        function cleanOldAutoBackups() {
            const backups = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith(`personalizedPlanAutoBackup_${APP_VERSION_KEY}_`)) {
                    backups.push(key);
                }
            }
            
            // Sort by date (newest first) and remove old ones
            backups.sort().reverse();
            if (backups.length > 5) {
                for (let i = 5; i < backups.length; i++) {
                    localStorage.removeItem(backups[i]);
                }
            }
        }

        function showBackupHistory() {
            try {
                const backups = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(`personalizedPlanAutoBackup_${APP_VERSION_KEY}_`)) {
                        const date = key.substring(`personalizedPlanAutoBackup_${APP_VERSION_KEY}_`.length);
                        backups.push(date);
                    }
                }
                
                const statusDiv = document.getElementById('dataManagementStatus');
                if (backups.length === 0) {
                    statusDiv.textContent = 'No auto backups found. Create one using the "Create Auto Backup" button.';
                    statusDiv.style.color = 'var(--md-orange-500)';
                } else {
                    backups.sort();
                    statusDiv.textContent = `Found ${backups.length} auto backups: ${backups.join(', ')}`;
                    statusDiv.style.color = 'var(--md-blue-500)';
                }
                
            } catch (error) {
                console.error('Backup history error:', error);
                const statusDiv = document.getElementById('dataManagementStatus');
                statusDiv.textContent = 'Failed to load backup history.';
                statusDiv.style.color = 'var(--md-red-500)';
            }
        }


        // Enhanced Import with validation for selective exports
        function importSelectiveData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Check if this is a selective export
                    if (importedData.exportType === 'selective') {
                        const confirmMessage = `Import selective data from ${new Date(importedData.exportDate).toLocaleDateString()}?\n\nThis is a selective export that will merge with your existing data.`;
                        
                        if (confirm(confirmMessage)) {
                            // Merge selective data instead of overwriting
                            if (importedData.exercisesE1RM) {
                                Object.assign(exercisesE1RM, importedData.exercisesE1RM);
                            }
                            if (importedData.e1RMChangeStatus) {
                                Object.assign(e1RMChangeStatus, importedData.e1RMChangeStatus);
                            }
                            if (importedData.bodyweightHistory) {
                                // Merge bodyweight history without duplicates
                                importedData.bodyweightHistory.forEach(entry => {
                                    const existingIndex = bodyweightHistory.findIndex(bw => bw.date === entry.date);
                                    if (existingIndex >= 0) {
                                        bodyweightHistory[existingIndex] = entry;
                                    } else {
                                        bodyweightHistory.push(entry);
                                    }
                                });
                                bodyweightHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
                            }
                            if (importedData.dailyLogs) {
                                // Merge daily logs
                                Object.entries(importedData.dailyLogs).forEach(([date, logData]) => {
                                    localStorage.setItem(`personalizedPlanDailyLog_${APP_VERSION_KEY}_${date}`, JSON.stringify(logData));
                                });
                            }

                            saveData();
                            renderE1RMTable();
                            renderBodyweightChart();
                            updateAttendanceSummary();
                            renderDailyLog();

                            const statusDiv = document.getElementById('dataManagementStatus');
                            statusDiv.textContent = `Selective data merged successfully from ${new Date(importedData.exportDate).toLocaleDateString()}`;
                            statusDiv.style.color = 'var(--md-green-500)';
                        }
                    } else {
                        // Use regular import for full exports
                        importData(event);
                    }
                    
                } catch (error) {
                    console.error('Selective import error:', error);
                    const statusDiv = document.getElementById('dataManagementStatus');
                    statusDiv.textContent = 'Import failed. Please check the file format.';
                    statusDiv.style.color = 'var(--md-red-500)';
                }
                
                event.target.value = '';
            };
            
            reader.readAsText(file);
        }



















        function refreshCurrentView() {
            // Refresh the current view to show updated data
            if (typeof loadBodyweightGraph === 'function') {
                loadBodyweightGraph();
            }
            if (typeof showAnalytics === 'function') {
                showAnalytics();
            }
            // Refresh any other components that might show the imported data
        }

        // Rest Timer Functions
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay() {
            const display = document.getElementById('timerDisplay');
            if (restTimerSeconds <= 0) {
                display.textContent = '0:00';
                display.style.color = 'var(--md-red-500)';
                if (restTimerInterval) {
                    clearInterval(restTimerInterval);
                    restTimerInterval = null;
                    
                    // Timer finished - play notification and show alert
                    if ('Notification' in window && Notification.permission === 'granted') {
                        new Notification('Rest Timer Complete!', {
                            body: 'Time to start your next set',
                            icon: '/favicon.ico'
                        });
                    }
                    
                    // Visual/audio notification
                    alert('Rest time complete! Ready for your next set?');
                    
                    // Reset timer state
                    restTimerSeconds = 0;
                    restTimerPaused = false;
                    document.getElementById('startTimerBtn').textContent = 'Start';
                }
            } else {
                display.textContent = formatTime(restTimerSeconds);
                // Color coding: green > 60s, yellow 30-60s, red < 30s
                if (restTimerSeconds > 60) {
                    display.style.color = 'var(--md-green-500)';
                } else if (restTimerSeconds > 30) {
                    display.style.color = 'orange';
                } else {
                    display.style.color = 'var(--md-red-500)';
                }
            }
        }

        function startRestTimer(seconds = null) {
            // Request notification permission on first use
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }

            if (seconds !== null) {
                // Starting with preset time
                restTimerSeconds = seconds;
                restTimerTotalSeconds = seconds;
            } else if (restTimerSeconds <= 0) {
                // Starting fresh with default time
                restTimerSeconds = 120; // Default 2 minutes
                restTimerTotalSeconds = 120;
            }
            // If seconds is null and restTimerSeconds > 0, we're resuming

            if (restTimerInterval) {
                clearInterval(restTimerInterval);
            }

            restTimerInterval = setInterval(() => {
                if (!restTimerPaused) {
                    restTimerSeconds--;
                    updateTimerDisplay();
                }
            }, 1000);

            restTimerPaused = false;
            document.getElementById('startTimerBtn').textContent = 'Resume';
            showRestTimer();
            updateTimerDisplay();
        }

        function pauseRestTimer() {
            restTimerPaused = !restTimerPaused;
            document.getElementById('pauseTimerBtn').textContent = restTimerPaused ? 'Resume' : 'Pause';
        }

        function stopRestTimer() {
            if (restTimerInterval) {
                clearInterval(restTimerInterval);
                restTimerInterval = null;
            }
            restTimerSeconds = 0;
            restTimerPaused = false;
            document.getElementById('startTimerBtn').textContent = 'Start';
            document.getElementById('pauseTimerBtn').textContent = 'Pause';
            updateTimerDisplay();
        }

        function startCustomTimer() {
            const minutes = parseInt(document.getElementById('customTimerMinutes').value);
            if (minutes && minutes > 0) {
                startRestTimer(minutes * 60);
                document.getElementById('customTimerMinutes').value = '';
            }
        }

        function showRestTimer() {
            document.getElementById('restTimer').classList.add('active');
            document.getElementById('toggleTimerBtn').textContent = 'Hide';
        }

        function hideRestTimer() {
            document.getElementById('restTimer').classList.remove('active');
            document.getElementById('toggleTimerBtn').textContent = 'Show';
        }

        function toggleRestTimer() {
            const timer = document.getElementById('restTimer');
            if (timer.classList.contains('active')) {
                hideRestTimer();
            } else {
                showRestTimer();
            }
        }

        function init() {
            loadData(); 
            const nav = document.getElementById('mainNav');
            const analyticsButton = nav.querySelector('button[data-tab="analyticsTab"]'); // Find analytics button
            const e1rmButton = nav.querySelector('button[data-tab="e1rmTab"]'); 

            Object.keys(USER_WORKOUT_PLAN).forEach(workoutKey => {
                const button = document.createElement('button');
                button.textContent = workoutKey; 
                button.setAttribute('data-day-key', workoutKey); 
                button.setAttribute('data-tab', 'workoutDayTab'); 
                button.onclick = () => displayWorkoutForDay(workoutKey);
                nav.insertBefore(button, analyticsButton); // Insert workout buttons before analytics button
            });
            
            document.getElementById('logBodyweightDate').value = todayKey; // Set default date for BW log
            renderE1RMTable(); 
            document.getElementById('currentDateDisplay').textContent = new Date(todayKey).toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'});
            renderDailyLog(); 
            renderBodyweightChart();
            updateAttendanceSummary();

            // Add event listeners for sliders
            document.getElementById('energyLevel').addEventListener('input', updateSliderValues);
            document.getElementById('stressLevel').addEventListener('input', updateSliderValues);
            updateSliderValues(); // Initial update

            // Start with the guide tab instead of auto-selecting a workout
            showTab('guideTab'); 
        }

        window.onclick = function(event) { 
            const modal = document.getElementById('accessoryLogModal');
            if (event.target == modal) {
                closeModal();
            }
        }

        // Global error handler
        window.addEventListener('error', function(event) {
            showError('Unexpected error occurred', event.error?.message || event.message);
        });

        window.addEventListener('unhandledrejection', function(event) {
            showError('Promise rejection', event.reason?.message || event.reason);
        });

        // ===== ANALYTICS FUNCTIONS =====
        
        // Global analytics variables
        let volumeChartInstance = null;
        let strengthChartInstance = null;
        let trainingLoadChartInstance = null;
        let frequencyChartInstance = null;

        // Exercise to muscle group mapping
        const EXERCISE_MUSCLE_GROUPS = {
            'Back-squat': ['Legs', 'Glutes'],
            'Bench Press': ['Chest', 'Shoulders', 'Triceps'],
            'Deadlift': ['Back', 'Legs', 'Glutes'],
            'OHP': ['Shoulders', 'Triceps'],
            'Weighted Pull-up': ['Back', 'Biceps'],
            'Hip-thrust': ['Glutes', 'Hamstrings'],
            'RDL': ['Hamstrings', 'Glutes', 'Back'],
            'Dips': ['Chest', 'Triceps', 'Shoulders'],
            'Chest-supported Row': ['Back', 'Biceps'],
            'Squat': ['Legs', 'Glutes'],
            'Row': ['Back', 'Biceps'],
            'Pull-up': ['Back', 'Biceps'],
            'Push-up': ['Chest', 'Shoulders', 'Triceps']
        };

        // Get daily logs for analytics
        function getAnalyticsData(daysBack = 30) {
            const data = [];
            const today = new Date();
            
            for (let i = 0; i < daysBack; i++) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateKey = date.toISOString().split('T')[0];
                
                const dailyLogKey = `personalizedPlanDailyLog_${APP_VERSION_KEY}_${dateKey}`;
                const storedLog = localStorage.getItem(dailyLogKey);
                
                if (storedLog) {
                    try {
                        const logData = JSON.parse(storedLog);
                        data.push({
                            date: dateKey,
                            dateObj: new Date(date),
                            log: logData
                        });
                    } catch (error) {
                        console.warn('Failed to parse log for date:', dateKey);
                    }
                }
            }
            
            return data.reverse(); // Return in chronological order
        }

        // Calculate volume per muscle group
        function calculateVolumeData(daysBack = 30) {
            const analyticsData = getAnalyticsData(daysBack);
            const muscleGroupVolumes = {};
            const dailyVolumes = [];
            
            analyticsData.forEach(dayData => {
                const dayVolumes = {};
                
                Object.keys(dayData.log).forEach(exerciseId => {
                    const exerciseLog = dayData.log[exerciseId];
                    
                    // Find exercise definition
                    let exerciseName = null;
                    Object.values(USER_WORKOUT_PLAN).forEach(workoutPlan => {
                        workoutPlan.forEach(exercise => {
                            if (exercise.id === exerciseId) {
                                exerciseName = exercise.liftName || exercise.name;
                            }
                        });
                    });
                    
                    if (!exerciseName || !exerciseLog.completed) return;
                    
                    // Calculate volume for this exercise
                    let exerciseVolume = 0;
                    
                    if (exerciseLog.actualWeight && exerciseLog.actualReps) {
                        // Single set exercise
                        exerciseVolume = exerciseLog.actualWeight * exerciseLog.actualReps;
                    } else {
                        // Multi-set exercise
                        for (let i = 1; i <= 6; i++) {
                            const setKey = `set${i}`;
                            if (exerciseLog[setKey] && exerciseLog[setKey].completed) {
                                const setData = exerciseLog[setKey];
                                if (setData.actualWeight && setData.actualReps) {
                                    exerciseVolume += setData.actualWeight * setData.actualReps;
                                }
                            }
                        }
                    }
                    
                    // Distribute volume to muscle groups
                    const muscleGroups = EXERCISE_MUSCLE_GROUPS[exerciseName] || [exerciseName];
                    const volumePerGroup = exerciseVolume / muscleGroups.length;
                    
                    muscleGroups.forEach(muscleGroup => {
                        if (!muscleGroupVolumes[muscleGroup]) {
                            muscleGroupVolumes[muscleGroup] = 0;
                        }
                        muscleGroupVolumes[muscleGroup] += volumePerGroup;
                        
                        if (!dayVolumes[muscleGroup]) {
                            dayVolumes[muscleGroup] = 0;
                        }
                        dayVolumes[muscleGroup] += volumePerGroup;
                    });
                });
                
                dailyVolumes.push({
                    date: dayData.date,
                    volumes: dayVolumes
                });
            });
            
            return { muscleGroupVolumes, dailyVolumes };
        }

        // Update volume analytics
        function updateVolumeAnalytics() {
            const daysBack = parseInt(document.getElementById('volumeTimeRange').value);
            const { muscleGroupVolumes, dailyVolumes } = calculateVolumeData(daysBack);
            
            // Update chart
            updateVolumeChart(dailyVolumes);
            
            // Update metrics
            updateVolumeMetrics(muscleGroupVolumes, daysBack);
        }

        // Update volume chart
        function updateVolumeChart(dailyVolumes) {
            const ctx = document.getElementById('volumeChart').getContext('2d');
            
            if (volumeChartInstance) {
                volumeChartInstance.destroy();
            }
            
            // Get all muscle groups
            const allMuscleGroups = new Set();
            dailyVolumes.forEach(day => {
                Object.keys(day.volumes).forEach(group => allMuscleGroups.add(group));
            });
            
            const muscleGroupsArray = Array.from(allMuscleGroups).sort();
            const colors = [
                '#673AB7', '#4CAF50', '#f44336', '#FF9800', '#2196F3', 
                '#9C27B0', '#795548', '#607D8B', '#E91E63', '#009688'
            ];
            
            const datasets = muscleGroupsArray.map((group, index) => ({
                label: group,
                data: dailyVolumes.map(day => day.volumes[group] || 0),
                borderColor: colors[index % colors.length],
                backgroundColor: colors[index % colors.length] + '20',
                fill: false,
                tension: 0.1
            }));
            
            volumeChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dailyVolumes.map(day => new Date(day.date).toLocaleDateString()),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Volume (kg × reps)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Training Volume by Muscle Group'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Update volume metrics
        function updateVolumeMetrics(muscleGroupVolumes, daysBack) {
            const container = document.getElementById('volumeMetrics');
            container.innerHTML = '';
            
            const sortedGroups = Object.entries(muscleGroupVolumes)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 6); // Top 6 muscle groups
            
            sortedGroups.forEach(([group, volume]) => {
                const card = document.createElement('div');
                card.className = 'metric-card';
                
                const averageDaily = volume / daysBack;
                
                card.innerHTML = `
                    <h4>${group}</h4>
                    <div class="metric-value">${Math.round(volume).toLocaleString()}</div>
                    <div class="metric-unit">kg × reps total</div>
                    <div class="metric-unit">${Math.round(averageDaily)} avg/day</div>
                `;
                
                container.appendChild(card);
            });
        }

        // Initialize analytics when tab is shown
        function initializeAnalytics() {
            updateVolumeAnalytics();
            updateStrengthChart();
            updateTrainingLoadAnalytics();
            updateFrequencyAnalytics();
            updatePerformanceMetrics();
        }

        // Strength progression chart implementation
        function updateStrengthChart() {
            const exerciseName = document.getElementById('strengthExercise').value;
            const daysBack = parseInt(document.getElementById('strengthTimeRange').value);
            
            const strengthData = getStrengthProgressionData(exerciseName, daysBack);
            updateStrengthChartDisplay(strengthData, exerciseName);
            updateStrengthMetrics(strengthData, exerciseName);
        }

        // Get strength progression data for a specific exercise
        function getStrengthProgressionData(exerciseName, daysBack) {
            const analyticsData = getAnalyticsData(daysBack);
            const progressionData = [];
            
            analyticsData.forEach(dayData => {
                // Look for exercises in the log that match our target
                Object.keys(dayData.log).forEach(exerciseId => {
                    const exerciseLog = dayData.log[exerciseId];
                    
                    // Find exercise definition to get the lift name
                    let foundExerciseName = null;
                    Object.values(USER_WORKOUT_PLAN).forEach(workoutPlan => {
                        workoutPlan.forEach(exercise => {
                            if (exercise.id === exerciseId) {
                                foundExerciseName = exercise.liftName || exercise.name;
                            }
                        });
                    });
                    
                    // Check if this matches our target exercise and has e1RM data
                    if (foundExerciseName === exerciseName && exerciseLog.completed) {
                        let maxE1RM = 0;
                        let bestSet = null;
                        
                        // Check main single set
                        if (exerciseLog.e1RMCalcFromSet) {
                            maxE1RM = Math.max(maxE1RM, exerciseLog.e1RMCalcFromSet);
                            if (exerciseLog.e1RMCalcFromSet === maxE1RM) {
                                bestSet = {
                                    weight: exerciseLog.actualWeight,
                                    reps: exerciseLog.actualReps,
                                    rpe: exerciseLog.actualRPE
                                };
                            }
                        }
                        
                        // Check multi-sets for e1RM calculations
                        for (let i = 1; i <= 6; i++) {
                            const setKey = `set${i}`;
                            const setData = exerciseLog[setKey];
                            if (setData && setData.completed && setData.actualWeight && setData.actualReps) {
                                // Calculate e1RM for this set
                                const effectiveReps = getEffectiveReps(setData.actualReps, setData.actualRPE || 8);
                                const setE1RM = calculateEpleyE1RM(setData.actualWeight, effectiveReps);
                                
                                if (setE1RM > maxE1RM) {
                                    maxE1RM = setE1RM;
                                    bestSet = {
                                        weight: setData.actualWeight,
                                        reps: setData.actualReps,
                                        rpe: setData.actualRPE || 8
                                    };
                                }
                            }
                        }
                        
                        // Use final e1RM if available, otherwise use calculated max
                        const finalE1RM = exerciseLog.groupE1RMAfterSet || maxE1RM;
                        
                        if (finalE1RM > 0) {
                            progressionData.push({
                                date: dayData.date,
                                dateObj: dayData.dateObj,
                                e1RM: finalE1RM,
                                bestSet: bestSet,
                                startingE1RM: exerciseLog.e1RMAtSetStart || 0
                            });
                        }
                    }
                });
            });
            
            // Sort by date and remove duplicates (keep highest e1RM per day)
            const dailyMaxE1RM = {};
            progressionData.forEach(entry => {
                if (!dailyMaxE1RM[entry.date] || entry.e1RM > dailyMaxE1RM[entry.date].e1RM) {
                    dailyMaxE1RM[entry.date] = entry;
                }
            });
            
            return Object.values(dailyMaxE1RM).sort((a, b) => a.dateObj - b.dateObj);
        }

        // Update the strength chart display
        function updateStrengthChartDisplay(strengthData, exerciseName) {
            const ctx = document.getElementById('strengthChart').getContext('2d');
            
            if (strengthChartInstance) {
                strengthChartInstance.destroy();
            }
            
            if (strengthData.length === 0) {
                // Show "no data" message
                ctx.fillStyle = '#666';
                ctx.font = '16px Roboto';
                ctx.textAlign = 'center';
                ctx.fillText('No data available for this exercise and time period', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }
            
            strengthChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: strengthData.map(entry => new Date(entry.date).toLocaleDateString()),
                    datasets: [{
                        label: 'e1RM (kg)',
                        data: strengthData.map(entry => entry.e1RM),
                        borderColor: '#673AB7',
                        backgroundColor: '#673AB720',
                        fill: false,
                        tension: 0.1,
                        pointBackgroundColor: '#673AB7',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'e1RM (kg)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `${exerciseName} Strength Progression`
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const dataPoint = strengthData[context.dataIndex];
                                    if (dataPoint.bestSet) {
                                        return `Best set: ${dataPoint.bestSet.weight}kg × ${dataPoint.bestSet.reps} @ RPE ${dataPoint.bestSet.rpe}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Update strength metrics
        function updateStrengthMetrics(strengthData, exerciseName) {
            const container = document.getElementById('strengthMetrics');
            container.innerHTML = '';
            
            if (strengthData.length === 0) {
                container.innerHTML = '<div class="metric-card"><h4>No Data</h4><div class="metric-value">-</div><div class="metric-unit">No training data found</div></div>';
                return;
            }
            
            const latestE1RM = strengthData[strengthData.length - 1].e1RM;
            const firstE1RM = strengthData[0].e1RM;
            const improvement = latestE1RM - firstE1RM;
            const improvementPercent = ((improvement / firstE1RM) * 100);
            
            // Current e1RM
            const currentCard = document.createElement('div');
            currentCard.className = 'metric-card';
            currentCard.innerHTML = `
                <h4>Current e1RM</h4>
                <div class="metric-value">${Math.round(latestE1RM)}</div>
                <div class="metric-unit">kg</div>
            `;
            container.appendChild(currentCard);
            
            // Total improvement
            const improvementCard = document.createElement('div');
            improvementCard.className = 'metric-card';
            const trendClass = improvement > 0 ? 'positive' : improvement < 0 ? 'negative' : 'neutral';
            improvementCard.innerHTML = `
                <h4>Total Gain</h4>
                <div class="metric-value">${improvement > 0 ? '+' : ''}${Math.round(improvement)}</div>
                <div class="metric-unit">kg</div>
                <div class="metric-trend ${trendClass}">${improvementPercent > 0 ? '+' : ''}${improvementPercent.toFixed(1)}%</div>
            `;
            container.appendChild(improvementCard);
            
            // Training sessions
            const sessionsCard = document.createElement('div');
            sessionsCard.className = 'metric-card';
            sessionsCard.innerHTML = `
                <h4>Sessions</h4>
                <div class="metric-value">${strengthData.length}</div>
                <div class="metric-unit">logged</div>
            `;
            container.appendChild(sessionsCard);
            
            // Best single session gain
            let maxDayGain = 0;
            for (let i = 1; i < strengthData.length; i++) {
                const dayGain = strengthData[i].e1RM - strengthData[i-1].e1RM;
                maxDayGain = Math.max(maxDayGain, dayGain);
            }
            
            const bestSessionCard = document.createElement('div');
            bestSessionCard.className = 'metric-card';
            bestSessionCard.innerHTML = `
                <h4>Best Session</h4>
                <div class="metric-value">+${Math.round(maxDayGain)}</div>
                <div class="metric-unit">kg gain</div>
            `;
            container.appendChild(bestSessionCard);
        }

        // Training load analytics implementation
        function updateTrainingLoadAnalytics() {
            const daysBack = parseInt(document.getElementById('loadTimeRange').value);
            const trainingLoadData = calculateTrainingLoadData(daysBack);
            
            updateTrainingLoadChart(trainingLoadData);
            updateTrainingLoadMetrics(trainingLoadData, daysBack);
        }

        // Calculate training load data (RPE-based stress)
        function calculateTrainingLoadData(daysBack) {
            const analyticsData = getAnalyticsData(daysBack);
            const dailyLoads = [];
            let totalLoad = 0;
            let totalSets = 0;
            const rpeDistribution = { 6: 0, 7: 0, 8: 0, 9: 0, 10: 0 };
            
            analyticsData.forEach(dayData => {
                let dayLoad = 0;
                let daySets = 0;
                
                Object.keys(dayData.log).forEach(exerciseId => {
                    const exerciseLog = dayData.log[exerciseId];
                    
                    if (!exerciseLog.completed) return;
                    
                    // Calculate load for single set exercises
                    if (exerciseLog.actualWeight && exerciseLog.actualReps && exerciseLog.actualRPE) {
                        const setVolume = exerciseLog.actualWeight * exerciseLog.actualReps;
                        const setLoad = setVolume * exerciseLog.actualRPE;
                        dayLoad += setLoad;
                        daySets += 1;
                        
                        // Track RPE distribution
                        const rpeKey = Math.floor(exerciseLog.actualRPE);
                        if (rpeDistribution.hasOwnProperty(rpeKey)) {
                            rpeDistribution[rpeKey] += 1;
                        }
                    }
                    
                    // Calculate load for multi-set exercises
                    for (let i = 1; i <= 6; i++) {
                        const setKey = `set${i}`;
                        const setData = exerciseLog[setKey];
                        if (setData && setData.completed && setData.actualWeight && setData.actualReps) {
                            const setVolume = setData.actualWeight * setData.actualReps;
                            const rpe = setData.actualRPE || 8; // Default RPE if not logged
                            const setLoad = setVolume * rpe;
                            dayLoad += setLoad;
                            daySets += 1;
                            
                            // Track RPE distribution
                            const rpeKey = Math.floor(rpe);
                            if (rpeDistribution.hasOwnProperty(rpeKey)) {
                                rpeDistribution[rpeKey] += 1;
                            }
                        }
                    }
                });
                
                dailyLoads.push({
                    date: dayData.date,
                    dateObj: dayData.dateObj,
                    load: dayLoad,
                    sets: daySets
                });
                
                totalLoad += dayLoad;
                totalSets += daySets;
            });
            
            return {
                dailyLoads,
                totalLoad,
                totalSets,
                averageLoad: totalLoad / Math.max(daysBack, 1),
                averageDailyLoad: totalLoad / Math.max(dailyLoads.filter(d => d.load > 0).length, 1),
                rpeDistribution
            };
        }

        // Update training load chart
        function updateTrainingLoadChart(trainingLoadData) {
            const ctx = document.getElementById('trainingLoadChart').getContext('2d');
            
            if (trainingLoadChartInstance) {
                trainingLoadChartInstance.destroy();
            }
            
            const dailyLoads = trainingLoadData.dailyLoads;
            
            if (dailyLoads.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px Roboto';
                ctx.textAlign = 'center';
                ctx.fillText('No training load data available', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }
            
            // Calculate 7-day rolling average
            const rollingAverage = [];
            for (let i = 0; i < dailyLoads.length; i++) {
                const start = Math.max(0, i - 6);
                const window = dailyLoads.slice(start, i + 1);
                const avgLoad = window.reduce((sum, day) => sum + day.load, 0) / window.length;
                rollingAverage.push(avgLoad);
            }
            
            trainingLoadChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dailyLoads.map(day => new Date(day.date).toLocaleDateString()),
                    datasets: [{
                        label: 'Daily Training Load',
                        data: dailyLoads.map(day => day.load),
                        backgroundColor: dailyLoads.map(day => {
                            // Color coding based on load intensity
                            if (day.load === 0) return '#e0e0e0';
                            if (day.load < 5000) return '#4CAF50';
                            if (day.load < 10000) return '#FF9800';
                            return '#f44336';
                        }),
                        borderWidth: 1
                    }, {
                        label: '7-Day Rolling Average',
                        data: rollingAverage,
                        type: 'line',
                        borderColor: '#673AB7',
                        backgroundColor: 'transparent',
                        fill: false,
                        tension: 0.1,
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Training Load (Volume × RPE)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Training Load & Stress Monitoring'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    if (context.dataset.label === 'Daily Training Load') {
                                        const dayData = dailyLoads[context.dataIndex];
                                        return `Sets: ${dayData.sets}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Update training load metrics
        function updateTrainingLoadMetrics(trainingLoadData, daysBack) {
            const container = document.getElementById('trainingLoadMetrics');
            container.innerHTML = '';
            
            const { totalLoad, totalSets, averageLoad, averageDailyLoad, rpeDistribution, dailyLoads } = trainingLoadData;
            
            // Average daily load
            const avgLoadCard = document.createElement('div');
            avgLoadCard.className = 'metric-card';
            avgLoadCard.innerHTML = `
                <h4>Avg Daily Load</h4>
                <div class="metric-value">${Math.round(averageDailyLoad).toLocaleString()}</div>
                <div class="metric-unit">load units</div>
            `;
            container.appendChild(avgLoadCard);
            
            // Total training load
            const totalLoadCard = document.createElement('div');
            totalLoadCard.className = 'metric-card';
            totalLoadCard.innerHTML = `
                <h4>Total Load</h4>
                <div class="metric-value">${Math.round(totalLoad).toLocaleString()}</div>
                <div class="metric-unit">${daysBack} days</div>
            `;
            container.appendChild(totalLoadCard);
            
            // Total sets
            const setsCard = document.createElement('div');
            setsCard.className = 'metric-card';
            setsCard.innerHTML = `
                <h4>Total Sets</h4>
                <div class="metric-value">${totalSets}</div>
                <div class="metric-unit">completed</div>
            `;
            container.appendChild(setsCard);
            
            // Average RPE
            const totalRPESets = Object.values(rpeDistribution).reduce((sum, count) => sum + count, 0);
            const weightedRPE = Object.entries(rpeDistribution).reduce((sum, [rpe, count]) => {
                return sum + (parseInt(rpe) * count);
            }, 0);
            const averageRPE = totalRPESets > 0 ? weightedRPE / totalRPESets : 0;
            
            const avgRPECard = document.createElement('div');
            avgRPECard.className = 'metric-card';
            avgRPECard.innerHTML = `
                <h4>Avg RPE</h4>
                <div class="metric-value">${averageRPE.toFixed(1)}</div>
                <div class="metric-unit">intensity</div>
            `;
            container.appendChild(avgRPECard);
            
            // Training frequency
            const activeDays = dailyLoads.filter(day => day.load > 0).length;
            const frequency = (activeDays / daysBack * 7).toFixed(1); // Days per week
            
            const frequencyCard = document.createElement('div');
            frequencyCard.className = 'metric-card';
            frequencyCard.innerHTML = `
                <h4>Frequency</h4>
                <div class="metric-value">${frequency}</div>
                <div class="metric-unit">days/week</div>
            `;
            container.appendChild(frequencyCard);
            
            // Load trend (last 7 days vs previous 7 days for longer periods)
            if (daysBack >= 14) {
                const recentLoads = dailyLoads.slice(-7);
                const previousLoads = dailyLoads.slice(-14, -7);
                
                const recentAvg = recentLoads.reduce((sum, day) => sum + day.load, 0) / 7;
                const previousAvg = previousLoads.reduce((sum, day) => sum + day.load, 0) / 7;
                const trendChange = recentAvg - previousAvg;
                const trendPercent = previousAvg > 0 ? (trendChange / previousAvg) * 100 : 0;
                
                const trendCard = document.createElement('div');
                trendCard.className = 'metric-card';
                const trendClass = trendChange > 0 ? 'positive' : trendChange < 0 ? 'negative' : 'neutral';
                trendCard.innerHTML = `
                    <h4>Load Trend</h4>
                    <div class="metric-value">${trendChange > 0 ? '+' : ''}${Math.round(trendChange)}</div>
                    <div class="metric-unit">vs prev week</div>
                    <div class="metric-trend ${trendClass}">${trendPercent > 0 ? '+' : ''}${trendPercent.toFixed(1)}%</div>
                `;
                container.appendChild(trendCard);
            }
        }

        // Frequency tracking implementation
        function updateFrequencyAnalytics() {
            const frequencyData = calculateFrequencyData(30); // Last 30 days for frequency analysis
            
            updateFrequencyChart(frequencyData);
            updateFrequencyMetrics(frequencyData);
        }

        // Calculate training frequency data per muscle group
        function calculateFrequencyData(daysBack) {
            const analyticsData = getAnalyticsData(daysBack);
            const muscleGroupFrequency = {};
            const weeklyFrequency = {}; // Track frequency per week
            
            // Initialize muscle groups
            Object.values(EXERCISE_MUSCLE_GROUPS).forEach(groups => {
                groups.forEach(group => {
                    if (!muscleGroupFrequency[group]) {
                        muscleGroupFrequency[group] = { totalDays: 0, weeks: {} };
                    }
                });
            });
            
            analyticsData.forEach(dayData => {
                const weekKey = getWeekKey(dayData.dateObj);
                const dayMuscleGroups = new Set();
                
                Object.keys(dayData.log).forEach(exerciseId => {
                    const exerciseLog = dayData.log[exerciseId];
                    
                    if (!exerciseLog.completed) return;
                    
                    // Find exercise definition
                    let exerciseName = null;
                    Object.values(USER_WORKOUT_PLAN).forEach(workoutPlan => {
                        workoutPlan.forEach(exercise => {
                            if (exercise.id === exerciseId) {
                                exerciseName = exercise.liftName || exercise.name;
                            }
                        });
                    });
                    
                    if (!exerciseName) return;
                    
                    // Get muscle groups for this exercise
                    const muscleGroups = EXERCISE_MUSCLE_GROUPS[exerciseName] || [exerciseName];
                    
                    // Track which muscle groups were trained this day
                    muscleGroups.forEach(group => {
                        dayMuscleGroups.add(group);
                    });
                });
                
                // Increment frequency counters for muscle groups trained this day
                dayMuscleGroups.forEach(group => {
                    if (muscleGroupFrequency[group]) {
                        muscleGroupFrequency[group].totalDays++;
                        
                        if (!muscleGroupFrequency[group].weeks[weekKey]) {
                            muscleGroupFrequency[group].weeks[weekKey] = 0;
                        }
                        muscleGroupFrequency[group].weeks[weekKey]++;
                    }
                });
            });
            
            // Calculate average frequency per week for each muscle group
            const numberOfWeeks = Math.max(1, Math.ceil(daysBack / 7));
            const muscleGroupStats = {};
            
            Object.entries(muscleGroupFrequency).forEach(([group, data]) => {
                const avgPerWeek = data.totalDays / numberOfWeeks;
                const weeklyData = Object.values(data.weeks);
                const maxPerWeek = weeklyData.length > 0 ? Math.max(...weeklyData) : 0;
                
                muscleGroupStats[group] = {
                    totalDays: data.totalDays,
                    avgPerWeek: avgPerWeek,
                    maxPerWeek: maxPerWeek,
                    weeksActive: weeklyData.length
                };
            });
            
            return {
                muscleGroupStats,
                numberOfWeeks,
                daysBack
            };
        }

        // Helper function to get week key (YYYY-WW format)
        function getWeekKey(date) {
            const year = date.getFullYear();
            const startOfYear = new Date(year, 0, 1);
            const dayOfYear = Math.floor((date - startOfYear) / (24 * 60 * 60 * 1000)) + 1;
            const weekNumber = Math.ceil(dayOfYear / 7);
            return `${year}-${weekNumber.toString().padStart(2, '0')}`;
        }

        // Update frequency chart
        function updateFrequencyChart(frequencyData) {
            const ctx = document.getElementById('frequencyChart').getContext('2d');
            
            if (frequencyChartInstance) {
                frequencyChartInstance.destroy();
            }
            
            const { muscleGroupStats } = frequencyData;
            const muscleGroups = Object.keys(muscleGroupStats)
                .filter(group => muscleGroupStats[group].totalDays > 0)
                .sort((a, b) => muscleGroupStats[b].avgPerWeek - muscleGroupStats[a].avgPerWeek);
            
            if (muscleGroups.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px Roboto';
                ctx.textAlign = 'center';
                ctx.fillText('No training frequency data available', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }
            
            const frequencies = muscleGroups.map(group => muscleGroupStats[group].avgPerWeek);
            const maxFrequencies = muscleGroups.map(group => muscleGroupStats[group].maxPerWeek);
            
            frequencyChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: muscleGroups,
                    datasets: [{
                        label: 'Average Frequency (days/week)',
                        data: frequencies,
                        backgroundColor: frequencies.map(freq => {
                            // Color coding based on frequency
                            if (freq >= 3) return '#4CAF50'; // Optimal (3+ times per week)
                            if (freq >= 2) return '#FF9800'; // Good (2+ times per week)
                            if (freq >= 1) return '#f44336'; // Suboptimal (1+ times per week)
                            return '#e0e0e0'; // Very low
                        }),
                        borderWidth: 1
                    }, {
                        label: 'Peak Frequency (max days/week)',
                        data: maxFrequencies,
                        backgroundColor: 'rgba(103, 58, 183, 0.3)',
                        borderColor: '#673AB7',
                        borderWidth: 2,
                        type: 'line',
                        fill: false,
                        tension: 0.1,
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 7,
                            title: {
                                display: true,
                                text: 'Days per Week'
                            },
                            ticks: {
                                stepSize: 1
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Muscle Groups'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Training Frequency by Muscle Group'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const group = context.label;
                                    const stats = muscleGroupStats[group];
                                    if (context.dataset.label.includes('Average')) {
                                        return `Total sessions: ${stats.totalDays}`;
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Update frequency metrics
        function updateFrequencyMetrics(frequencyData) {
            const container = document.getElementById('frequencyMetrics');
            container.innerHTML = '';
            
            const { muscleGroupStats, numberOfWeeks } = frequencyData;
            
            // Overall training frequency
            const totalSessions = Object.values(muscleGroupStats).reduce((sum, stats) => sum + stats.totalDays, 0);
            const avgSessionsPerWeek = totalSessions / numberOfWeeks;
            
            const overallCard = document.createElement('div');
            overallCard.className = 'metric-card';
            overallCard.innerHTML = `
                <h4>Weekly Sessions</h4>
                <div class="metric-value">${avgSessionsPerWeek.toFixed(1)}</div>
                <div class="metric-unit">avg per week</div>
            `;
            container.appendChild(overallCard);
            
            // Most trained muscle group
            const mostTrainedGroup = Object.entries(muscleGroupStats)
                .filter(([group, stats]) => stats.totalDays > 0)
                .sort(([,a], [,b]) => b.avgPerWeek - a.avgPerWeek)[0];
            
            if (mostTrainedGroup) {
                const [group, stats] = mostTrainedGroup;
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <h4>Most Trained</h4>
                    <div class="metric-value">${group}</div>
                    <div class="metric-unit">${stats.avgPerWeek.toFixed(1)}x/week</div>
                `;
                container.appendChild(card);
            }
            
            // Least trained muscle group (that has been trained)
            const leastTrainedGroup = Object.entries(muscleGroupStats)
                .filter(([group, stats]) => stats.totalDays > 0)
                .sort(([,a], [,b]) => a.avgPerWeek - b.avgPerWeek)[0];
            
            if (leastTrainedGroup) {
                const [group, stats] = leastTrainedGroup;
                const card = document.createElement('div');
                card.className = 'metric-card';
                card.innerHTML = `
                    <h4>Least Trained</h4>
                    <div class="metric-value">${group}</div>
                    <div class="metric-unit">${stats.avgPerWeek.toFixed(1)}x/week</div>
                `;
                container.appendChild(card);
            }
            
            // Optimal frequency count (muscle groups trained 2+ times per week)
            const optimalGroups = Object.values(muscleGroupStats).filter(stats => stats.avgPerWeek >= 2).length;
            const totalActiveGroups = Object.values(muscleGroupStats).filter(stats => stats.totalDays > 0).length;
            
            const optimalCard = document.createElement('div');
            optimalCard.className = 'metric-card';
            const optimalPercent = totalActiveGroups > 0 ? (optimalGroups / totalActiveGroups * 100) : 0;
            optimalCard.innerHTML = `
                <h4>Optimal Frequency</h4>
                <div class="metric-value">${optimalGroups}/${totalActiveGroups}</div>
                <div class="metric-unit">groups 2+x/week</div>
                <div class="metric-trend ${optimalPercent >= 70 ? 'positive' : optimalPercent >= 50 ? 'neutral' : 'negative'}">${optimalPercent.toFixed(0)}%</div>
            `;
            container.appendChild(optimalCard);
            
            // Balance score (how evenly distributed is the training)
            const frequencies = Object.values(muscleGroupStats)
                .filter(stats => stats.totalDays > 0)
                .map(stats => stats.avgPerWeek);
            
            if (frequencies.length > 0) {
                const mean = frequencies.reduce((sum, freq) => sum + freq, 0) / frequencies.length;
                const variance = frequencies.reduce((sum, freq) => sum + Math.pow(freq - mean, 2), 0) / frequencies.length;
                const stdDev = Math.sqrt(variance);
                const balanceScore = Math.max(0, 100 - (stdDev / mean * 100));
                
                const balanceCard = document.createElement('div');
                balanceCard.className = 'metric-card';
                balanceCard.innerHTML = `
                    <h4>Balance Score</h4>
                    <div class="metric-value">${balanceScore.toFixed(0)}</div>
                    <div class="metric-unit">% balanced</div>
                    <div class="metric-trend ${balanceScore >= 80 ? 'positive' : balanceScore >= 60 ? 'neutral' : 'negative'}">
                        ${balanceScore >= 80 ? 'Excellent' : balanceScore >= 60 ? 'Good' : 'Needs work'}
                    </div>
                `;
                container.appendChild(balanceCard);
            }
        }

        // Performance metrics dashboard implementation
        function updatePerformanceMetrics() {
            const performanceData = calculatePerformanceMetrics(30); // Last 30 days
            displayPerformanceMetrics(performanceData);
        }

        // Calculate comprehensive performance metrics
        function calculatePerformanceMetrics(daysBack) {
            const analyticsData = getAnalyticsData(daysBack);
            let totalSets = 0;
            let totalReps = 0;
            let totalVolume = 0;
            let totalTrainingDays = 0;
            let rpeSum = 0;
            let rpeCount = 0;
            const dailyPerformance = [];
            const exerciseProgress = {};
            
            // Process each day's data
            analyticsData.forEach(dayData => {
                let dayVolume = 0;
                let daySets = 0;
                let dayReps = 0;
                let dayRPE = 0;
                let dayRPECount = 0;
                let hasTraining = false;
                
                Object.keys(dayData.log).forEach(exerciseId => {
                    const exerciseLog = dayData.log[exerciseId];
                    
                    if (!exerciseLog.completed) return;
                    hasTraining = true;
                    
                    // Get exercise name
                    let exerciseName = null;
                    Object.values(USER_WORKOUT_PLAN).forEach(workoutPlan => {
                        workoutPlan.forEach(exercise => {
                            if (exercise.id === exerciseId) {
                                exerciseName = exercise.liftName || exercise.name;
                            }
                        });
                    });
                    
                    if (!exerciseName) return;
                    
                    // Initialize exercise tracking
                    if (!exerciseProgress[exerciseName]) {
                        exerciseProgress[exerciseName] = {
                            sessions: 0,
                            totalVolume: 0,
                            maxWeight: 0,
                            avgRPE: 0,
                            rpeSum: 0,
                            rpeCount: 0
                        };
                    }
                    
                    exerciseProgress[exerciseName].sessions++;
                    
                    // Process single set exercises
                    if (exerciseLog.actualWeight && exerciseLog.actualReps) {
                        const setVolume = exerciseLog.actualWeight * exerciseLog.actualReps;
                        dayVolume += setVolume;
                        daySets++;
                        dayReps += exerciseLog.actualReps;
                        
                        exerciseProgress[exerciseName].totalVolume += setVolume;
                        exerciseProgress[exerciseName].maxWeight = Math.max(
                            exerciseProgress[exerciseName].maxWeight, 
                            exerciseLog.actualWeight
                        );
                        
                        if (exerciseLog.actualRPE) {
                            dayRPE += exerciseLog.actualRPE;
                            dayRPECount++;
                            rpeSum += exerciseLog.actualRPE;
                            rpeCount++;
                            
                            exerciseProgress[exerciseName].rpeSum += exerciseLog.actualRPE;
                            exerciseProgress[exerciseName].rpeCount++;
                        }
                    }
                    
                    // Process multi-set exercises
                    for (let i = 1; i <= 6; i++) {
                        const setKey = `set${i}`;
                        const setData = exerciseLog[setKey];
                        if (setData && setData.completed && setData.actualWeight && setData.actualReps) {
                            const setVolume = setData.actualWeight * setData.actualReps;
                            dayVolume += setVolume;
                            daySets++;
                            dayReps += setData.actualReps;
                            
                            exerciseProgress[exerciseName].totalVolume += setVolume;
                            exerciseProgress[exerciseName].maxWeight = Math.max(
                                exerciseProgress[exerciseName].maxWeight, 
                                setData.actualWeight
                            );
                            
                            const rpe = setData.actualRPE || 8;
                            dayRPE += rpe;
                            dayRPECount++;
                            rpeSum += rpe;
                            rpeCount++;
                            
                            exerciseProgress[exerciseName].rpeSum += rpe;
                            exerciseProgress[exerciseName].rpeCount++;
                        }
                    }
                });
                
                if (hasTraining) {
                    totalTrainingDays++;
                    totalVolume += dayVolume;
                    totalSets += daySets;
                    totalReps += dayReps;
                    
                    dailyPerformance.push({
                        date: dayData.date,
                        volume: dayVolume,
                        sets: daySets,
                        reps: dayReps,
                        avgRPE: dayRPECount > 0 ? dayRPE / dayRPECount : 0
                    });
                }
            });
            
            // Calculate averages and trends
            const avgRPE = rpeCount > 0 ? rpeSum / rpeCount : 0;
            const avgVolumePerDay = totalTrainingDays > 0 ? totalVolume / totalTrainingDays : 0;
            const avgSetsPerDay = totalTrainingDays > 0 ? totalSets / totalTrainingDays : 0;
            const avgRepsPerSet = totalSets > 0 ? totalReps / totalSets : 0;
            const consistency = (totalTrainingDays / daysBack) * 100;
            
            // Calculate volume trend (comparing first half vs second half)
            const halfPoint = Math.floor(dailyPerformance.length / 2);
            const firstHalf = dailyPerformance.slice(0, halfPoint);
            const secondHalf = dailyPerformance.slice(halfPoint);
            
            const firstHalfAvgVolume = firstHalf.length > 0 ? 
                firstHalf.reduce((sum, day) => sum + day.volume, 0) / firstHalf.length : 0;
            const secondHalfAvgVolume = secondHalf.length > 0 ? 
                secondHalf.reduce((sum, day) => sum + day.volume, 0) / secondHalf.length : 0;
            
            const volumeTrend = firstHalfAvgVolume > 0 ? 
                ((secondHalfAvgVolume - firstHalfAvgVolume) / firstHalfAvgVolume) * 100 : 0;
            
            // Process exercise progress data
            Object.keys(exerciseProgress).forEach(exerciseName => {
                const progress = exerciseProgress[exerciseName];
                progress.avgRPE = progress.rpeCount > 0 ? progress.rpeSum / progress.rpeCount : 0;
                progress.avgVolumePerSession = progress.sessions > 0 ? progress.totalVolume / progress.sessions : 0;
            });
            
            return {
                totalVolume,
                totalSets,
                totalReps,
                totalTrainingDays,
                avgRPE,
                avgVolumePerDay,
                avgSetsPerDay,
                avgRepsPerSet,
                consistency,
                volumeTrend,
                dailyPerformance,
                exerciseProgress,
                daysBack
            };
        }

        // Display performance metrics
        function displayPerformanceMetrics(performanceData) {
            const container = document.getElementById('performanceMetrics');
            container.innerHTML = '';
            
            const {
                totalVolume, totalSets, totalReps, totalTrainingDays, avgRPE,
                avgVolumePerDay, avgSetsPerDay, avgRepsPerSet, consistency,
                volumeTrend, exerciseProgress, daysBack
            } = performanceData;
            
            // Training Consistency
            const consistencyCard = document.createElement('div');
            consistencyCard.className = 'metric-card';
            const consistencyClass = consistency >= 70 ? 'positive' : consistency >= 50 ? 'neutral' : 'negative';
            consistencyCard.innerHTML = `
                <h4>Consistency</h4>
                <div class="metric-value">${consistency.toFixed(0)}</div>
                <div class="metric-unit">% of days</div>
                <div class="metric-trend ${consistencyClass}">${totalTrainingDays}/${daysBack} days</div>
            `;
            container.appendChild(consistencyCard);
            
            // Average RPE
            const rpeCard = document.createElement('div');
            rpeCard.className = 'metric-card';
            const rpeClass = avgRPE >= 8.5 ? 'negative' : avgRPE >= 7.5 ? 'positive' : 'neutral';
            rpeCard.innerHTML = `
                <h4>Avg Intensity</h4>
                <div class="metric-value">${avgRPE.toFixed(1)}</div>
                <div class="metric-unit">RPE</div>
                <div class="metric-trend ${rpeClass}">
                    ${avgRPE >= 8.5 ? 'Very High' : avgRPE >= 7.5 ? 'Optimal' : avgRPE >= 6.5 ? 'Moderate' : 'Low'}
                </div>
            `;
            container.appendChild(rpeCard);
            
            // Volume Trend
            const volumeTrendCard = document.createElement('div');
            volumeTrendCard.className = 'metric-card';
            const trendClass = volumeTrend > 5 ? 'positive' : volumeTrend < -5 ? 'negative' : 'neutral';
            volumeTrendCard.innerHTML = `
                <h4>Volume Trend</h4>
                <div class="metric-value">${volumeTrend > 0 ? '+' : ''}${volumeTrend.toFixed(1)}</div>
                <div class="metric-unit">% change</div>
                <div class="metric-trend ${trendClass}">
                    ${volumeTrend > 5 ? 'Increasing' : volumeTrend < -5 ? 'Decreasing' : 'Stable'}
                </div>
            `;
            container.appendChild(volumeTrendCard);
            
            // Average Daily Volume
            const avgVolumeCard = document.createElement('div');
            avgVolumeCard.className = 'metric-card';
            avgVolumeCard.innerHTML = `
                <h4>Daily Volume</h4>
                <div class="metric-value">${Math.round(avgVolumePerDay).toLocaleString()}</div>
                <div class="metric-unit">kg × reps</div>
            `;
            container.appendChild(avgVolumeCard);
            
            // Average Sets per Day
            const avgSetsCard = document.createElement('div');
            avgSetsCard.className = 'metric-card';
            avgSetsCard.innerHTML = `
                <h4>Daily Sets</h4>
                <div class="metric-value">${Math.round(avgSetsPerDay)}</div>
                <div class="metric-unit">sets/day</div>
            `;
            container.appendChild(avgSetsCard);
            
            // Average Reps per Set
            const avgRepsCard = document.createElement('div');
            avgRepsCard.className = 'metric-card';
            const repsClass = avgRepsPerSet >= 8 ? 'neutral' : avgRepsPerSet >= 5 ? 'positive' : 'negative';
            avgRepsCard.innerHTML = `
                <h4>Reps/Set</h4>
                <div class="metric-value">${avgRepsPerSet.toFixed(1)}</div>
                <div class="metric-unit">avg reps</div>
                <div class="metric-trend ${repsClass}">
                    ${avgRepsPerSet >= 8 ? 'Hypertrophy' : avgRepsPerSet >= 5 ? 'Strength' : 'Power/Max'}
                </div>
            `;
            container.appendChild(avgRepsCard);
            
            // Most Improved Exercise
            const exercisesByVolume = Object.entries(exerciseProgress)
                .filter(([name, data]) => data.sessions >= 2)
                .sort(([,a], [,b]) => b.totalVolume - a.totalVolume);
            
            if (exercisesByVolume.length > 0) {
                const [topExercise, topData] = exercisesByVolume[0];
                const topExerciseCard = document.createElement('div');
                topExerciseCard.className = 'metric-card';
                topExerciseCard.innerHTML = `
                    <h4>Top Exercise</h4>
                    <div class="metric-value" style="font-size: 1.2em;">${topExercise}</div>
                    <div class="metric-unit">${Math.round(topData.totalVolume).toLocaleString()} volume</div>
                    <div class="metric-trend neutral">${topData.sessions} sessions</div>
                `;
                container.appendChild(topExerciseCard);
            }
            
            // Training Quality Score (composite metric)
            const qualityScore = calculateTrainingQuality(performanceData);
            const qualityCard = document.createElement('div');
            qualityCard.className = 'metric-card';
            const qualityClass = qualityScore >= 80 ? 'positive' : qualityScore >= 60 ? 'neutral' : 'negative';
            qualityCard.innerHTML = `
                <h4>Quality Score</h4>
                <div class="metric-value">${qualityScore}</div>
                <div class="metric-unit">out of 100</div>
                <div class="metric-trend ${qualityClass}">
                    ${qualityScore >= 80 ? 'Excellent' : qualityScore >= 60 ? 'Good' : 'Needs Work'}
                </div>
            `;
            container.appendChild(qualityCard);
        }

        // Calculate training quality score (composite metric)
        function calculateTrainingQuality(performanceData) {
            const { consistency, avgRPE, volumeTrend, avgSetsPerDay, totalTrainingDays } = performanceData;
            
            // Score components (0-100 each)
            let consistencyScore = Math.min(100, consistency * 1.4); // Boost consistency importance
            let intensityScore = avgRPE >= 7 && avgRPE <= 8.5 ? 100 : avgRPE > 8.5 ? 70 : 50; // Optimal RPE range
            let volumeScore = volumeTrend >= -10 && volumeTrend <= 20 ? 100 : 70; // Stable to moderate growth
            let frequencyScore = Math.min(100, (avgSetsPerDay / 12) * 100); // Up to 12 sets per day is optimal
            let durationScore = totalTrainingDays >= 15 ? 100 : (totalTrainingDays / 15) * 100; // At least 15 days for good score
            
            // Weighted average
            const weights = {
                consistency: 0.3,
                intensity: 0.2,
                volume: 0.2,
                frequency: 0.15,
                duration: 0.15
            };
            
            const weightedScore = (
                consistencyScore * weights.consistency +
                intensityScore * weights.intensity +
                volumeScore * weights.volume +
                frequencyScore * weights.frequency +
                durationScore * weights.duration
            );
            
            return Math.round(weightedScore);
        }


        // Initialize app
        try {
            init();
            
        } catch (error) {
            showError('Failed to initialize app', error.message);
        }
    </script>
</body>
</html>
